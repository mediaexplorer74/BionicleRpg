
// Type: GameManager.Map.Generation.FastNoiseLite
// Assembly: BionicleRpg, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A3C16972-042F-4654-B76B-0749FB030FA7
// Modded by [M]edia[E]xplorer

using System;
using System.Runtime.CompilerServices;

#nullable disable
namespace GameManager.Map.Generation
{
  public class FastNoiseLite
  {
    private const short INLINE = 256;
    private const short OPTIMISE = 512;
    private int mSeed = 1337;
    private float mFrequency = 0.01f;
    private FastNoiseLite.NoiseType mNoiseType;
    private FastNoiseLite.RotationType3D mRotationType3D;
    private FastNoiseLite.TransformType3D mTransformType3D = FastNoiseLite.TransformType3D.DefaultOpenSimplex2;
    private FastNoiseLite.FractalType mFractalType;
    private int mOctaves = 3;
    private float mLacunarity = 2f;
    private float mGain = 0.5f;
    private float mWeightedStrength;
    private float mPingPongStrength = 2f;
    private float mFractalBounding = 0.5714286f;
    private FastNoiseLite.CellularDistanceFunction mCellularDistanceFunction = FastNoiseLite.CellularDistanceFunction.EuclideanSq;
    private FastNoiseLite.CellularReturnType mCellularReturnType = FastNoiseLite.CellularReturnType.Distance;
    private float mCellularJitterModifier = 1f;
    private FastNoiseLite.DomainWarpType mDomainWarpType;
    private FastNoiseLite.TransformType3D mWarpTransformType3D = FastNoiseLite.TransformType3D.DefaultOpenSimplex2;
    private float mDomainWarpAmp = 1f;
    private static readonly float[] Gradients2D = new float[256]
    {
      0.130526185f,
      0.9914449f,
      0.382683426f,
      0.9238795f,
      0.6087614f,
      0.7933533f,
      0.7933533f,
      0.6087614f,
      0.9238795f,
      0.382683426f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      -0.130526185f,
      0.9238795f,
      -0.382683426f,
      0.7933533f,
      -0.6087614f,
      0.6087614f,
      -0.7933533f,
      0.382683426f,
      -0.9238795f,
      0.130526185f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      -0.382683426f,
      -0.9238795f,
      -0.6087614f,
      -0.7933533f,
      -0.7933533f,
      -0.6087614f,
      -0.9238795f,
      -0.382683426f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      0.130526185f,
      -0.9238795f,
      0.382683426f,
      -0.7933533f,
      0.6087614f,
      -0.6087614f,
      0.7933533f,
      -0.382683426f,
      0.9238795f,
      -0.130526185f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      0.382683426f,
      0.9238795f,
      0.6087614f,
      0.7933533f,
      0.7933533f,
      0.6087614f,
      0.9238795f,
      0.382683426f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      -0.130526185f,
      0.9238795f,
      -0.382683426f,
      0.7933533f,
      -0.6087614f,
      0.6087614f,
      -0.7933533f,
      0.382683426f,
      -0.9238795f,
      0.130526185f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      -0.382683426f,
      -0.9238795f,
      -0.6087614f,
      -0.7933533f,
      -0.7933533f,
      -0.6087614f,
      -0.9238795f,
      -0.382683426f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      0.130526185f,
      -0.9238795f,
      0.382683426f,
      -0.7933533f,
      0.6087614f,
      -0.6087614f,
      0.7933533f,
      -0.382683426f,
      0.9238795f,
      -0.130526185f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      0.382683426f,
      0.9238795f,
      0.6087614f,
      0.7933533f,
      0.7933533f,
      0.6087614f,
      0.9238795f,
      0.382683426f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      -0.130526185f,
      0.9238795f,
      -0.382683426f,
      0.7933533f,
      -0.6087614f,
      0.6087614f,
      -0.7933533f,
      0.382683426f,
      -0.9238795f,
      0.130526185f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      -0.382683426f,
      -0.9238795f,
      -0.6087614f,
      -0.7933533f,
      -0.7933533f,
      -0.6087614f,
      -0.9238795f,
      -0.382683426f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      0.130526185f,
      -0.9238795f,
      0.382683426f,
      -0.7933533f,
      0.6087614f,
      -0.6087614f,
      0.7933533f,
      -0.382683426f,
      0.9238795f,
      -0.130526185f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      0.382683426f,
      0.9238795f,
      0.6087614f,
      0.7933533f,
      0.7933533f,
      0.6087614f,
      0.9238795f,
      0.382683426f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      -0.130526185f,
      0.9238795f,
      -0.382683426f,
      0.7933533f,
      -0.6087614f,
      0.6087614f,
      -0.7933533f,
      0.382683426f,
      -0.9238795f,
      0.130526185f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      -0.382683426f,
      -0.9238795f,
      -0.6087614f,
      -0.7933533f,
      -0.7933533f,
      -0.6087614f,
      -0.9238795f,
      -0.382683426f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      0.130526185f,
      -0.9238795f,
      0.382683426f,
      -0.7933533f,
      0.6087614f,
      -0.6087614f,
      0.7933533f,
      -0.382683426f,
      0.9238795f,
      -0.130526185f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      0.382683426f,
      0.9238795f,
      0.6087614f,
      0.7933533f,
      0.7933533f,
      0.6087614f,
      0.9238795f,
      0.382683426f,
      0.9914449f,
      0.130526185f,
      0.9914449f,
      -0.130526185f,
      0.9238795f,
      -0.382683426f,
      0.7933533f,
      -0.6087614f,
      0.6087614f,
      -0.7933533f,
      0.382683426f,
      -0.9238795f,
      0.130526185f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      -0.382683426f,
      -0.9238795f,
      -0.6087614f,
      -0.7933533f,
      -0.7933533f,
      -0.6087614f,
      -0.9238795f,
      -0.382683426f,
      -0.9914449f,
      -0.130526185f,
      -0.9914449f,
      0.130526185f,
      -0.9238795f,
      0.382683426f,
      -0.7933533f,
      0.6087614f,
      -0.6087614f,
      0.7933533f,
      -0.382683426f,
      0.9238795f,
      -0.130526185f,
      0.9914449f,
      0.382683426f,
      0.9238795f,
      0.9238795f,
      0.382683426f,
      0.9238795f,
      -0.382683426f,
      0.382683426f,
      -0.9238795f,
      -0.382683426f,
      -0.9238795f,
      -0.9238795f,
      -0.382683426f,
      -0.9238795f,
      0.382683426f,
      -0.382683426f,
      0.9238795f
    };
    private static readonly float[] RandVecs2D = new float[512]
    {
      -0.2700222f,
      -0.9628541f,
      0.386309266f,
      -0.9223693f,
      0.04444859f,
      -0.9990117f,
      -0.599252343f,
      -0.800560236f,
      -0.781928f,
      0.62336874f,
      0.9464672f,
      0.322799921f,
      -0.6514147f,
      -0.7587219f,
      0.937847257f,
      0.347048372f,
      -0.8497876f,
      -0.527125239f,
      -0.879042566f,
      0.476743251f,
      -0.8923003f,
      -0.451442361f,
      -0.379844427f,
      -0.9250504f,
      -0.9951651f,
      0.09821638f,
      0.7724398f,
      -0.635088f,
      0.757328331f,
      -0.6530343f,
      -0.9928005f,
      -0.119780056f,
      -0.05326657f,
      0.998580337f,
      0.975425363f,
      -0.220330074f,
      -0.766501844f,
      0.642242134f,
      0.9916367f,
      0.129060611f,
      -0.994696856f,
      0.102850378f,
      -0.537920535f,
      -0.8429955f,
      0.502281547f,
      -0.864704132f,
      0.455982149f,
      -0.8899889f,
      -0.8659131f,
      -0.50019443f,
      0.08794584f,
      -0.9961253f,
      -0.5051685f,
      0.8630207f,
      0.7753185f,
      -0.6315704f,
      -0.692194462f,
      0.72171104f,
      -0.519165933f,
      -0.854673445f,
      0.8978623f,
      -0.4402764f,
      -0.170677409f,
      0.985326946f,
      -0.935343f,
      -0.353742063f,
      -0.999240458f,
      0.0389674678f,
      -0.2882064f,
      -0.9575683f,
      -0.966381133f,
      0.2571138f,
      -0.875971437f,
      -0.482363015f,
      -0.8303123f,
      -0.557298362f,
      0.0511013381f,
      -0.998693466f,
      -0.855837345f,
      -0.517245054f,
      0.0988702551f,
      0.9951003f,
      0.9189016f,
      0.394486785f,
      -0.243937582f,
      -0.969790936f,
      -0.812140942f,
      -0.5834613f,
      -0.99104315f,
      0.133542135f,
      0.8492424f,
      -0.528003156f,
      -0.9717839f,
      -0.235872954f,
      0.9949457f,
      0.100414209f,
      0.6241065f,
      -0.7813392f,
      0.6629103f,
      0.748698831f,
      -0.7197418f,
      0.6942418f,
      -0.8143371f,
      -0.580392241f,
      0.104521051f,
      -0.9945227f,
      -0.10659261f,
      -0.99430275f,
      0.445799679f,
      -0.8951328f,
      0.105547406f,
      0.99441427f,
      -0.9927903f,
      0.119864449f,
      -0.833436668f,
      0.552615047f,
      0.9115562f,
      -0.4111756f,
      0.8285545f,
      -0.55990845f,
      0.7217098f,
      -0.6921958f,
      0.494049281f,
      -0.8694339f,
      -0.36523214f,
      -0.9309165f,
      -0.9696607f,
      0.244454846f,
      0.0892550945f,
      -0.9960088f,
      0.5354071f,
      -0.8445941f,
      -0.105357617f,
      0.9944344f,
      -0.989028454f,
      0.1477251f,
      0.004856105f,
      0.9999882f,
      0.988559842f,
      0.150829136f,
      0.928612947f,
      -0.371049821f,
      -0.5832394f,
      -0.8123003f,
      0.301520765f,
      0.9534596f,
      -0.957511067f,
      0.288396567f,
      0.9715802f,
      -0.236710548f,
      0.2299818f,
      0.973194957f,
      0.9557638f,
      -0.2941352f,
      0.7409561f,
      0.671553433f,
      -0.9971514f,
      -0.07542631f,
      0.69057107f,
      -0.7232645f,
      -0.2907137f,
      -0.9568101f,
      0.5912778f,
      -0.80646795f,
      -0.945459247f,
      -0.3257405f,
      0.666445553f,
      0.7455537f,
      0.6236135f,
      0.781732857f,
      0.9126994f,
      -0.408631653f,
      -0.8191762f,
      0.573541939f,
      -0.8812746f,
      -0.4726046f,
      0.995331347f,
      0.09651673f,
      0.985565066f,
      -0.169296965f,
      -0.8495981f,
      0.527430654f,
      0.6174854f,
      -0.786582351f,
      0.850815654f,
      0.5254643f,
      0.998503268f,
      -0.0546925f,
      0.197137162f,
      -0.980375946f,
      0.660785556f,
      -0.7505747f,
      -0.0309749413f,
      0.9995202f,
      -0.6731661f,
      0.739491343f,
      -0.719501853f,
      -0.694490552f,
      0.972751141f,
      0.2318516f,
      0.9997059f,
      -0.02425069f,
      0.442178756f,
      -0.896926939f,
      0.9981351f,
      -0.0610436723f,
      -0.9173661f,
      -0.398044556f,
      -0.81500566f,
      -0.579453f,
      -0.878933132f,
      0.476945f,
      0.0158605836f,
      0.999874234f,
      -0.8095465f,
      0.5870558f,
      -0.9165899f,
      -0.399828672f,
      -0.8023543f,
      0.5968481f,
      -0.5176738f,
      0.855578065f,
      -95f * (float) Math.PI / 366f,
      -0.578840554f,
      0.402201027f,
      -0.915551364f,
      -0.9052557f,
      -0.4248672f,
      0.7317446f,
      0.681579f,
      -0.564763248f,
      -0.825253f,
      -0.8403276f,
      -0.542078853f,
      -0.931428134f,
      0.363925248f,
      0.523819864f,
      0.851829052f,
      0.7432804f,
      -0.66898f,
      -0.9853716f,
      -0.170419738f,
      0.460146874f,
      0.887842834f,
      0.8258554f,
      0.563881934f,
      0.6182366f,
      0.785992f,
      0.833150268f,
      -0.553046644f,
      0.150030747f,
      0.9886813f,
      -0.6623304f,
      -0.7492119f,
      -0.668598652f,
      0.743623435f,
      0.7025606f,
      0.7116239f,
      -0.541938961f,
      -0.840417862f,
      -0.338861644f,
      0.9408362f,
      0.833153f,
      0.553042531f,
      -0.29897207f,
      -0.954261839f,
      0.2638523f,
      0.9645631f,
      0.124108739f,
      -0.9922686f,
      -0.7282649f,
      -0.6852957f,
      0.69625f,
      0.717799366f,
      -0.918353558f,
      0.395761f,
      -0.6326102f,
      -0.7744703f,
      -0.9331892f,
      -0.35938552f,
      -0.115377933f,
      -0.993321657f,
      0.9514975f,
      -0.307656556f,
      -0.08987977f,
      -0.9959526f,
      0.6678497f,
      0.7442962f,
      0.795240045f,
      -0.6062947f,
      -0.6462007f,
      -0.7631675f,
      -0.273359865f,
      0.961911857f,
      0.966959f,
      -0.254931837f,
      -0.9792895f,
      0.202465191f,
      -0.5369503f,
      -0.843613863f,
      -0.270036459f,
      -0.9628501f,
      -0.6400277f,
      0.768351853f,
      -0.785453737f,
      -0.6189204f,
      0.0600590557f,
      -0.9981948f,
      -0.0245577041f,
      0.9996984f,
      -1080f / (521f * (float)Math.PI),
      0.7514095f,
      -0.625389457f,
      -0.7803128f,
      -0.6210409f,
      -0.7837782f,
      0.8348889f,
      0.550418556f,
      -0.15922752f,
      0.9872419f,
      0.836762249f,
      0.547566354f,
      -0.8675754f,
      -0.4973057f,
      -0.202266261f,
      -0.97933054f,
      0.939919f,
      0.341397554f,
      0.987740457f,
      -0.1561049f,
      -0.903445542f,
      0.428702831f,
      0.126980424f,
      -0.9919052f,
      -0.3819601f,
      0.924178839f,
      0.9754626f,
      0.220165253f,
      -0.320401579f,
      -0.947281837f,
      -0.9874761f,
      0.157768741f,
      0.0253534839f,
      -0.999678552f,
      0.4835131f,
      -0.8753371f,
      -0.28508f,
      -0.9585037f,
      -0.06805516f,
      -0.997681558f,
      -0.7885244f,
      -0.615003467f,
      0.3185392f,
      -0.9479097f,
      0.8880043f,
      0.459835142f,
      0.647692144f,
      -0.761902153f,
      0.982024133f,
      0.188755423f,
      0.935727537f,
      -0.352723718f,
      -0.889489532f,
      0.456955522f,
      0.7922791f,
      0.6101588f,
      0.748381853f,
      0.663268149f,
      -0.728893f,
      -0.684627652f,
      0.8729033f,
      -0.487893283f,
      0.8288346f,
      0.5594937f,
      0.08074567f,
      0.996734738f,
      0.979914844f,
      -0.1994165f,
      -0.5807307f,
      -0.814095736f,
      -0.470004976f,
      -0.8826638f,
      0.2409493f,
      0.9705377f,
      0.9437817f,
      -0.330569416f,
      -0.892799854f,
      -0.45045355f,
      -0.806962252f,
      0.590603054f,
      0.0625897348f,
      0.998039365f,
      -0.931259751f,
      0.364355981f,
      0.577744961f,
      0.816217363f,
      -0.3360096f,
      -0.9418586f,
      0.697932065f,
      -0.716163933f,
      -0.00200815732f,
      -0.999998f,
      -0.182729438f,
      -0.983163238f,
      -0.6523912f,
      0.7578824f,
      -0.430262685f,
      -0.9027037f,
      -0.9985126f,
      -0.0545209125f,
      -0.0102810217f,
      -0.999947131f,
      -0.494607121f,
      0.869116664f,
      -0.299935f,
      0.953959644f,
      0.8165472f,
      0.5772787f,
      0.269746035f,
      0.9629315f,
      -0.7306287f,
      -0.682774961f,
      -0.7590952f,
      -0.650979638f,
      -0.9070538f,
      0.4210146f,
      -0.5104861f,
      -0.859886f,
      0.861335039f,
      0.5080373f,
      0.500788152f,
      -0.8655699f,
      -0.6541582f,
      0.7563578f,
      -0.838275552f,
      -0.54524684f,
      0.6940071f,
      0.7199682f,
      0.06950936f,
      0.9975813f,
      0.170294225f,
      -0.9853933f,
      0.269597322f,
      0.9629731f,
      0.551961243f,
      -0.833869755f,
      0.2256575f,
      -0.9742067f,
      0.421526283f,
      -0.9068162f,
      0.488187343f,
      -0.872738838f,
      -0.3683855f,
      -0.929673135f,
      -0.982539058f,
      0.18605645f,
      0.812564731f,
      0.582871f,
      0.3196461f,
      -0.947537f,
      0.9570914f,
      0.289786249f,
      -0.6876655f,
      -0.7260276f,
      -0.9988771f,
      -0.04737673f,
      -0.1250179f,
      0.9921545f,
      -0.828013361f,
      0.560708344f,
      0.932486355f,
      -0.361205131f,
      0.639465332f,
      0.7688199f,
      -0.0162384715f,
      -0.999868155f,
      -0.995501459f,
      -0.0947461352f,
      -0.8145332f,
      0.580117f,
      0.4037328f,
      -0.914876938f,
      0.9944263f,
      0.10543368f,
      -0.16247116f,
      0.9867133f,
      -0.9949488f,
      -0.100383878f,
      -0.699530244f,
      0.714603f,
      0.5263415f,
      -0.850273252f,
      -96f * (float) Math.PI / 559f,
      0.8419714f,
      0.65793705f,
      0.7530729f,
      0.014267588f,
      -0.9998982f,
      -0.6734384f,
      0.7392433f,
      0.6394121f,
      -0.7688642f,
      0.9211571f,
      0.389190853f,
      -0.146637216f,
      -0.98919034f,
      -0.7823181f,
      0.6228791f,
      -0.5039611f,
      -0.8637264f,
      -0.774312f,
      -0.632804f
    };
    private static readonly float[] Gradients3D = new float[256]
    {
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      0.0f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      0.0f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      0.0f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      0.0f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      0.0f,
      1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      -1f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      1f,
      -1f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f,
      0.0f,
      1f,
      1f,
      0.0f,
      0.0f,
      0.0f,
      -1f,
      1f,
      0.0f,
      -1f,
      1f,
      0.0f,
      0.0f,
      0.0f,
      -1f,
      -1f,
      0.0f
    };
    private static readonly float[] RandVecs3D = new float[1024]
    {
      -0.7292737f,
      -0.661843956f,
      0.17355819f,
      0.0f,
      0.7902921f,
      -0.5480887f,
      -0.2739291f,
      0.0f,
      0.7217579f,
      0.622621238f,
      -0.3023381f,
      0.0f,
      0.5656831f,
      -0.8208298f,
      -0.079000026f,
      0.0f,
      0.760049045f,
      -0.555597961f,
      -0.337099969f,
      0.0f,
      0.371394575f,
      0.501126468f,
      0.78162545f,
      0.0f,
      -0.127706245f,
      -0.4254439f,
      -0.8959289f,
      0.0f,
      -0.2881561f,
      -0.5815839f,
      0.7607406f,
      0.0f,
      0.5849561f,
      -0.6628202f,
      -0.4674352f,
      0.0f,
      0.330717117f,
      0.0391653739f,
      0.94291687f,
      0.0f,
      0.8712122f,
      -0.411337435f,
      -0.267938167f,
      0.0f,
      0.580981f,
      0.7021916f,
      0.411567777f,
      0.0f,
      0.5037569f,
      0.6330057f,
      -0.5878204f,
      0.0f,
      0.449371219f,
      0.6013902f,
      0.6606023f,
      0.0f,
      -0.6878404f,
      0.0901889056f,
      -0.7202372f,
      0.0f,
      -0.595895648f,
      -0.646935046f,
      0.475797653f,
      0.0f,
      -0.5127052f,
      0.1946922f,
      -0.836198747f,
      0.0f,
      -0.991150737f,
      -0.0541027635f,
      -0.121215314f,
      0.0f,
      -0.214972109f,
      0.9720882f,
      -0.09397608f,
      0.0f,
      -0.7518651f,
      -0.542805731f,
      0.374246955f,
      0.0f,
      0.5237069f,
      0.8516377f,
      -0.0210781787f,
      0.0f,
      0.6333505f,
      0.192616716f,
      -0.749510467f,
      0.0f,
      -0.06788242f,
      0.39983058f,
      0.9140719f,
      0.0f,
      -0.55386287f,
      -0.472989678f,
      -0.6852129f,
      0.0f,
      -0.726145566f,
      -0.5911991f,
      0.350993335f,
      0.0f,
      -0.9229275f,
      -0.178280875f,
      0.341204941f,
      0.0f,
      -0.6968815f,
      0.651127458f,
      0.300648034f,
      0.0f,
      0.960804462f,
      -0.209836319f,
      -0.18117249f,
      0.0f,
      0.0681714639f,
      -0.9743405f,
      0.214506909f,
      0.0f,
      -0.3577285f,
      -0.6697087f,
      -0.650784552f,
      0.0f,
      -0.186862111f,
      0.7648617f,
      -0.616497457f,
      0.0f,
      -0.654169738f,
      0.3967915f,
      0.643908739f,
      0.0f,
      0.699334f,
      -0.6164538f,
      0.361823916f,
      0.0f,
      -0.154666573f,
      0.6291284f,
      0.7617583f,
      0.0f,
      -0.6841613f,
      -0.2580482f,
      -0.682154238f,
      0.0f,
      0.5383981f,
      0.4258655f,
      0.727163f,
      0.0f,
      -0.5026988f,
      -0.7939833f,
      -0.3418837f,
      0.0f,
      0.320297182f,
      0.283441544f,
      0.9039196f,
      0.0f,
      0.86832273f,
      -0.000376265642f,
      -0.495999515f,
      0.0f,
      0.791120052f,
      -0.0851104558f,
      0.605710566f,
      0.0f,
      -0.04011016f,
      -0.439724863f,
      0.8972364f,
      0.0f,
      0.914512f,
      0.357934624f,
      -0.188548759f,
      0.0f,
      -0.961203933f,
      -0.275648415f,
      0.0102466689f,
      0.0f,
      0.651036143f,
      -0.287779927f,
      -0.702377856f,
      0.0f,
      -0.204178631f,
      0.736523747f,
      0.6448596f,
      0.0f,
      -0.7718264f,
      0.379062682f,
      0.5104856f,
      0.0f,
      -0.306008279f,
      -0.7692988f,
      0.56083715f,
      0.0f,
      0.454007328f,
      -0.5024843f,
      0.735789955f,
      0.0f,
      0.481679559f,
      0.6021208f,
      -0.636738f,
      0.0f,
      0.696198046f,
      -0.322219729f,
      0.6414692f,
      0.0f,
      -0.653216064f,
      -0.6781149f,
      0.336851567f,
      0.0f,
      0.508930147f,
      -0.615466237f,
      -0.601823449f,
      0.0f,
      -0.163591981f,
      -0.9133605f,
      -0.372840881f,
      0.0f,
      0.5240802f,
      -0.8437664f,
      0.115750588f,
      0.0f,
      0.5902587f,
      0.4983818f,
      -0.634988368f,
      0.0f,
      0.5863228f,
      0.494764745f,
      0.6414308f,
      0.0f,
      0.6779335f,
      0.234134525f,
      0.6968409f,
      0.0f,
      0.7177054f,
      -0.685897946f,
      0.120178632f,
      0.0f,
      -0.532882f,
      -0.5205125f,
      0.6671608f,
      0.0f,
      -0.8654874f,
      -0.07007271f,
      -0.4960054f,
      0.0f,
      -0.286181f,
      0.795208931f,
      0.534549534f,
      0.0f,
      -0.0484952964f,
      0.981083632f,
      -0.187411562f,
      0.0f,
      -0.635852158f,
      0.605834842f,
      0.478180021f,
      0.0f,
      0.62547946f,
      -0.286161959f,
      0.725869656f,
      0.0f,
      -0.258526f,
      0.506194949f,
      -0.8227582f,
      0.0f,
      0.0213630684f,
      0.506401658f,
      -0.862033f,
      0.0f,
      0.200111777f,
      0.859926343f,
      0.46955505f,
      0.0f,
      0.474356145f,
      0.6014985f,
      -0.6427953f,
      0.0f,
      0.6622994f,
      -0.520247459f,
      -0.539168f,
      0.0f,
      0.08084973f,
      -0.653272033f,
      0.7527941f,
      0.0f,
      -0.6893687f,
      0.0592860356f,
      0.7219805f,
      0.0f,
      -0.112188712f,
      -0.967318535f,
      0.227395251f,
      0.0f,
      0.7344116f,
      0.59796685f,
      -0.3210533f,
      0.0f,
      0.5789393f,
      -0.248884976f,
      0.776457f,
      0.0f,
      0.698818266f,
      0.355716974f,
      -0.6205791f,
      0.0f,
      -0.863684535f,
      -0.274877131f,
      -0.4224826f,
      0.0f,
      -0.4247028f,
      -0.464088082f,
      0.777335048f,
      0.0f,
      0.5257723f,
      -0.842701733f,
      0.115832992f,
      0.0f,
      0.934383035f,
      0.316302478f,
      -0.163954392f,
      0.0f,
      -0.101683639f,
      -0.8057303f,
      -0.583488762f,
      0.0f,
      -0.6529239f,
      0.506021261f,
      -0.5635893f,
      0.0f,
      -0.246528611f,
      -0.9668206f,
      -0.06694497f,
      0.0f,
      -0.9776897f,
      -0.209925056f,
      -0.00736882538f,
      0.0f,
      0.7736893f,
      0.573424459f,
      0.2694238f,
      0.0f,
      -0.6095088f,
      0.4995679f,
      0.6155737f,
      0.0f,
      0.5794535f,
      0.7434547f,
      0.333929241f,
      0.0f,
      -0.8226211f,
      0.0814258158f,
      0.562729359f,
      0.0f,
      -0.510385454f,
      0.470366776f,
      0.719904f,
      0.0f,
      -0.5764972f,
      -0.0723165646f,
      -0.813892663f,
      0.0f,
      0.7250629f,
      0.39499715f,
      -0.56414634f,
      0.0f,
      -0.1525424f,
      0.486084074f,
      -0.8604958f,
      0.0f,
      -0.55509764f,
      -0.495782077f,
      0.6678823f,
      0.0f,
      -0.188361436f,
      0.914586961f,
      0.35784173f,
      0.0f,
      0.762555659f,
      -0.541440845f,
      -0.354048967f,
      0.0f,
      -0.5870232f,
      -0.3226498f,
      -0.7424964f,
      0.0f,
      0.305112422f,
      0.2262544f,
      -0.9250488f,
      0.0f,
      0.637957633f,
      0.577242434f,
      -0.509707034f,
      0.0f,
      -0.5966776f,
      0.145485237f,
      -0.7891831f,
      0.0f,
      -0.65833056f,
      0.655548751f,
      -0.369941473f,
      0.0f,
      0.743489265f,
      0.235108465f,
      0.6260573f,
      0.0f,
      0.5562114f,
      0.826436043f,
      -0.08736329f,
      0.0f,
      -0.302894f,
      -0.8251527f,
      0.476841927f,
      0.0f,
      0.112934381f,
      -0.9858884f,
      -0.123571075f,
      0.0f,
      0.5937653f,
      -0.5896814f,
      0.5474657f,
      0.0f,
      0.6757964f,
      -0.583575845f,
      -0.450264841f,
      0.0f,
      0.7242303f,
      -0.115271978f,
      0.679855049f,
      0.0f,
      -0.9511914f,
      0.0753624f,
      -0.299258083f,
      0.0f,
      0.2539471f,
      -0.188633934f,
      0.9486454f,
      0.0f,
      0.5714336f,
      -0.167945087f,
      -0.8032796f,
      0.0f,
      -0.06778235f,
      0.39782694f,
      0.9149532f,
      0.0f,
      0.6074973f,
      0.73306f,
      -0.305892259f,
      0.0f,
      -0.543547869f,
      0.167582244f,
      0.8224791f,
      0.0f,
      -133f * (float) Math.PI / 711f,
      -0.3380045f,
      -0.7351187f,
      0.0f,
      -0.796756268f,
      0.0409782268f,
      -0.602909863f,
      0.0f,
      -0.199635088f,
      0.8706295f,
      0.4496111f,
      0.0f,
      -0.0278766025f,
      -0.910623252f,
      -0.4122962f,
      0.0f,
      -0.7797626f,
      -0.6257635f,
      0.0197577551f,
      0.0f,
      -0.5211233f,
      0.740164459f,
      -0.424955457f,
      0.0f,
      0.8575425f,
      0.4053273f,
      -0.316750169f,
      0.0f,
      0.104522333f,
      0.8390196f,
      -0.533967435f,
      0.0f,
      0.3501823f,
      0.9242524f,
      -0.152085021f,
      0.0f,
      0.198784992f,
      0.0764761344f,
      0.9770547f,
      0.0f,
      0.784599662f,
      0.6066257f,
      -0.128096417f,
      0.0f,
      0.09006737f,
      -0.975098968f,
      -0.20265691f,
      0.0f,
      -0.827434361f,
      -0.542299569f,
      0.145820364f,
      0.0f,
      -0.348579764f,
      -0.41580227f,
      0.8400004f,
      0.0f,
      -0.2471779f,
      -0.730482f,
      -0.6366311f,
      0.0f,
      -0.3700155f,
      0.8577948f,
      0.356758446f,
      0.0f,
      0.591339469f,
      -0.548311949f,
      -0.591330349f,
      0.0f,
      0.120487355f,
      -0.7626472f,
      -0.6354935f,
      0.0f,
      0.6169593f,
      0.03079648f,
      0.7863923f,
      0.0f,
      0.12581569f,
      -0.664083f,
      -0.73699677f,
      0.0f,
      -0.6477565f,
      -0.174014732f,
      -0.741707742f,
      0.0f,
      0.6217889f,
      -0.7804431f,
      -0.06547655f,
      0.0f,
      0.6589943f,
      -0.6096988f,
      0.44044736f,
      0.0f,
      -0.268983752f,
      -0.6732403f,
      -0.688763559f,
      0.0f,
      -0.38497752f,
      0.567654252f,
      0.7277094f,
      0.0f,
      0.57544446f,
      0.811047137f,
      -0.105196349f,
      0.0f,
      0.914159358f,
      0.3832948f,
      0.131900564f,
      0.0f,
      -0.107925318f,
      0.9245494f,
      0.365459353f,
      0.0f,
      0.3779771f,
      0.304314882f,
      0.874371648f,
      0.0f,
      -0.214288518f,
      -0.8259286f,
      0.5214617f,
      0.0f,
      0.580254436f,
      0.414809853f,
      -0.7008834f,
      0.0f,
      -0.198266089f,
      0.856716156f,
      -0.476159662f,
      0.0f,
      -0.0338155366f,
      0.377318084f,
      -0.9254661f,
      0.0f,
      -0.686792254f,
      -0.6656598f,
      0.29191336f,
      0.0f,
      0.7731743f,
      -0.287579358f,
      -0.565243f,
      0.0f,
      -0.09655942f,
      0.91937083f,
      -0.3813575f,
      0.0f,
      0.271570235f,
      -0.957791f,
      -0.09426606f,
      0.0f,
      0.245101571f,
      -0.6917999f,
      -0.6792188f,
      0.0f,
      0.97770077f,
      -0.175385535f,
      0.115503654f,
      0.0f,
      -0.522474f,
      0.8521607f,
      0.0290361587f,
      0.0f,
      -0.773488045f,
      -0.526129246f,
      0.353417963f,
      0.0f,
      -0.71344924f,
      -0.269547254f,
      0.6467878f,
      0.0f,
      0.164403722f,
      0.5105846f,
      -0.843963742f,
      0.0f,
      0.6494636f,
      0.0558561124f,
      0.7583384f,
      0.0f,
      -0.4711971f,
      0.501728058f,
      -0.7254256f,
      0.0f,
      -0.633576453f,
      -0.238168627f,
      -0.7361091f,
      0.0f,
      -0.9021533f,
      -0.2709478f,
      -0.335718185f,
      0.0f,
      -0.3793711f,
      0.8722581f,
      0.3086152f,
      0.0f,
      -0.685559869f,
      -0.325014323f,
      0.6514394f,
      0.0f,
      0.290094227f,
      -0.7799058f,
      -0.5546101f,
      0.0f,
      -0.209831938f,
      0.8503707f,
      0.482535154f,
      0.0f,
      -0.459260374f,
      0.6598504f,
      -0.5947077f,
      0.0f,
      0.871594548f,
      0.09616365f,
      -0.480703115f,
      0.0f,
      -0.6776666f,
      0.711850464f,
      -0.1844907f,
      0.0f,
      0.7044378f,
      0.3124276f,
      0.637304f,
      0.0f,
      -0.7052319f,
      -0.240109324f,
      -0.6670798f,
      0.0f,
      0.0819210038f,
      -0.720733643f,
      -0.688354552f,
      0.0f,
      -0.6993681f,
      -0.5875763f,
      -0.4069869f,
      0.0f,
      -0.128145441f,
      0.6419896f,
      0.755928636f,
      0.0f,
      -0.6337388f,
      -0.678547144f,
      -0.3714147f,
      0.0f,
      0.5565052f,
      -0.216888756f,
      -0.8020357f,
      0.0f,
      -0.579155445f,
      0.7244372f,
      -0.3738579f,
      0.0f,
      0.11757791f,
      -0.7096451f,
      0.69467926f,
      0.0f,
      -0.613462f,
      0.132363111f,
      0.7785528f,
      0.0f,
      0.698463559f,
      -0.0298051629f,
      -0.7150247f,
      0.0f,
      0.831808269f,
      -0.3930172f,
      0.391959757f,
      0.0f,
      0.146957636f,
      0.055416517f,
      -0.98758924f,
      0.0f,
      0.708868563f,
      -0.2690504f,
      0.652010143f,
      0.0f,
      0.27260533f,
      0.67369765f,
      -0.686889946f,
      0.0f,
      -0.65912956f,
      0.303545862f,
      -0.688046634f,
      0.0f,
      0.481513143f,
      -0.752827f,
      0.4487723f,
      0.0f,
      0.943001f,
      0.167564735f,
      -0.287526131f,
      0.0f,
      0.434802949f,
      0.7695305f,
      -0.46772778f,
      0.0f,
      0.393199623f,
      0.5944736f,
      0.701423645f,
      0.0f,
      0.725433648f,
      -0.603925645f,
      0.330181479f,
      0.0f,
      0.759023547f,
      -0.6506083f,
      0.0243331324f,
      0.0f,
      -0.8552769f,
      -0.3430043f,
      0.388393581f,
      0.0f,
      -0.6139747f,
      0.6981725f,
      0.368225753f,
      0.0f,
      -0.746590555f,
      -0.575201f,
      0.334284931f,
      0.0f,
      0.5730066f,
      0.8105555f,
      -0.121091679f,
      0.0f,
      -0.922587752f,
      -0.3475211f,
      -0.167514041f,
      0.0f,
      -0.71058166f,
      -0.471969217f,
      -0.5218417f,
      0.0f,
      -0.0856461f,
      0.358300149f,
      0.9296697f,
      0.0f,
      -0.8279698f,
      -0.2043157f,
      0.5222271f,
      0.0f,
      0.427944034f,
      0.278166f,
      0.8599346f,
      0.0f,
      0.539908f,
      -0.785712063f,
      -0.3019204f,
      0.0f,
      0.5678404f,
      -0.5495414f,
      -0.612830758f,
      0.0f,
      -0.9896071f,
      0.136563912f,
      -0.0450341851f,
      0.0f,
      -0.6154343f,
      -0.644087553f,
      0.454303741f,
      0.0f,
      0.107420437f,
      -0.794634044f,
      0.597509444f,
      0.0f,
      -0.359545f,
      -0.888553f,
      0.284957826f,
      0.0f,
      -0.218040526f,
      0.1529889f,
      0.9638738f,
      0.0f,
      -0.7277432f,
      -0.61640507f,
      -0.300723463f,
      0.0f,
      0.7249729f,
      -0.00669719465f,
      0.688744843f,
      0.0f,
      -0.5553659f,
      -0.5336586f,
      0.6377908f,
      0.0f,
      0.5137558f,
      0.797620833f,
      -0.316f,
      0.0f,
      -0.3794025f,
      0.924560845f,
      -0.0352275148f,
      0.0f,
      0.822924852f,
      0.27453658f,
      -0.497417659f,
      0.0f,
      -0.5404114f,
      0.60911417f,
      0.5804614f,
      0.0f,
      0.8036582f,
      -0.270302951f,
      0.5301602f,
      0.0f,
      0.604431868f,
      0.683296859f,
      0.409594327f,
      0.0f,
      0.06389989f,
      0.965820849f,
      -0.2512108f,
      0.0f,
      0.108711332f,
      0.74024713f,
      -0.6634878f,
      0.0f,
      -0.7134277f,
      -0.6926784f,
      0.105912849f,
      0.0f,
      0.645889759f,
      -0.57245487f,
      -0.50509584f,
      0.0f,
      -0.6553931f,
      0.73814714f,
      0.159995615f,
      0.0f,
      0.391096145f,
      0.918887138f,
      -0.05186756f,
      0.0f,
      -0.487902254f,
      -0.5904377f,
      0.642911136f,
      0.0f,
      0.601479f,
      0.770744145f,
      -0.210182011f,
      0.0f,
      -0.5677173f,
      0.7511361f,
      0.336885184f,
      0.0f,
      0.7858574f,
      0.226674661f,
      0.5753667f,
      0.0f,
      -0.452034563f,
      -0.6042227f,
      -0.656185746f,
      0.0f,
      0.00227211625f,
      0.4132844f,
      -0.9105992f,
      0.0f,
      -0.581575155f,
      -0.5162926f,
      0.6286591f,
      0.0f,
      -0.03703705f,
      0.8273786f,
      0.5604221f,
      0.0f,
      -0.511969268f,
      0.795354366f,
      -0.324498f,
      0.0f,
      -0.268241733f,
      -0.957229f,
      -0.10843876f,
      0.0f,
      -0.232248276f,
      -0.9679131f,
      -0.09594243f,
      0.0f,
      0.3554329f,
      -0.8881506f,
      0.291300625f,
      0.0f,
      0.734652042f,
      -0.4371373f,
      0.5188423f,
      0.0f,
      0.998512f,
      0.0465901121f,
      -0.0283394456f,
      0.0f,
      -0.37276876f,
      -0.9082481f,
      0.190075725f,
      0.0f,
      0.9173738f,
      -0.3483642f,
      0.192529842f,
      0.0f,
      0.2714911f,
      0.41475296f,
      -0.868488669f,
      0.0f,
      0.5131763f,
      -0.711633444f,
      0.4798207f,
      0.0f,
      -0.873735368f,
      0.188869923f,
      -0.448235065f,
      0.0f,
      0.846004367f,
      -0.3725218f,
      0.38145f,
      0.0f,
      0.897872746f,
      -0.178020909f,
      -0.402657539f,
      0.0f,
      0.217806563f,
      -0.9698323f,
      -0.109478951f,
      0.0f,
      -0.151803136f,
      -0.7788918f,
      -0.6085091f,
      0.0f,
      -0.2600385f,
      -0.4755398f,
      -0.840382f,
      0.0f,
      0.5723135f,
      -0.7474341f,
      -0.337341845f,
      0.0f,
      -0.7174141f,
      0.169901714f,
      -0.675611138f,
      0.0f,
      -0.6841808f,
      0.0214570761f,
      -0.728996754f,
      0.0f,
      -0.2007448f,
      0.06555606f,
      -0.9774477f,
      0.0f,
      -0.114880368f,
      -0.8044887f,
      0.5827524f,
      0.0f,
      -0.787035f,
      0.03447489f,
      0.6159443f,
      0.0f,
      -0.201559648f,
      0.685987234f,
      0.699138939f,
      0.0f,
      -0.0858108252f,
      -0.10920836f,
      -0.990308046f,
      0.0f,
      0.5532693f,
      0.732525051f,
      -0.396610767f,
      0.0f,
      -0.184248939f,
      -0.9777375f,
      -0.100407675f,
      0.0f,
      0.07754738f,
      -0.9111506f,
      0.404711038f,
      0.0f,
      0.139983848f,
      0.7601631f,
      -0.634473443f,
      0.0f,
      0.448441923f,
      -0.84528923f,
      0.290492535f,
      0.0f
    };
    private const int PrimeX = 501125321;
    private const int PrimeY = 1136930381;
    private const int PrimeZ = 1720413743;

    public FastNoiseLite(int seed = 1337) => this.SetSeed(seed);

    public void SetSeed(int seed) => this.mSeed = seed;

    public void SetFrequency(float frequency) => this.mFrequency = frequency;

    public void SetNoiseType(FastNoiseLite.NoiseType noiseType)
    {
      this.mNoiseType = noiseType;
      this.UpdateTransformType3D();
    }

    public void SetRotationType3D(FastNoiseLite.RotationType3D rotationType3D)
    {
      this.mRotationType3D = rotationType3D;
      this.UpdateTransformType3D();
      this.UpdateWarpTransformType3D();
    }

    public void SetFractalType(FastNoiseLite.FractalType fractalType)
    {
      this.mFractalType = fractalType;
    }

    public void SetFractalOctaves(int octaves)
    {
      this.mOctaves = octaves;
      this.CalculateFractalBounding();
    }

    public void SetFractalLacunarity(float lacunarity) => this.mLacunarity = lacunarity;

    public void SetFractalGain(float gain)
    {
      this.mGain = gain;
      this.CalculateFractalBounding();
    }

    public void SetFractalWeightedStrength(float weightedStrength)
    {
      this.mWeightedStrength = weightedStrength;
    }

    public void SetFractalPingPongStrength(float pingPongStrength)
    {
      this.mPingPongStrength = pingPongStrength;
    }

    public void SetCellularDistanceFunction(
      FastNoiseLite.CellularDistanceFunction cellularDistanceFunction)
    {
      this.mCellularDistanceFunction = cellularDistanceFunction;
    }

    public void SetCellularReturnType(
      FastNoiseLite.CellularReturnType cellularReturnType)
    {
      this.mCellularReturnType = cellularReturnType;
    }

    public void SetCellularJitter(float cellularJitter)
    {
      this.mCellularJitterModifier = cellularJitter;
    }

    public void SetDomainWarpType(FastNoiseLite.DomainWarpType domainWarpType)
    {
      this.mDomainWarpType = domainWarpType;
      this.UpdateWarpTransformType3D();
    }

    public void SetDomainWarpAmp(float domainWarpAmp) => this.mDomainWarpAmp = domainWarpAmp;

    //[MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public float GetNoise(float x, float y)
    {
      this.TransformNoiseCoordinate(ref x, ref y);
      switch (this.mFractalType)
      {
        case FastNoiseLite.FractalType.FBm:
          return this.GenFractalFBm(x, y);
        case FastNoiseLite.FractalType.Ridged:
          return this.GenFractalRidged(x, y);
        case FastNoiseLite.FractalType.PingPong:
          return this.GenFractalPingPong(x, y);
        default:
          return this.GenNoiseSingle(this.mSeed, x, y);
      }
    }

    //[MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public float GetNoise(float x, float y, float z)
    {
      this.TransformNoiseCoordinate(ref x, ref y, ref z);
      switch (this.mFractalType)
      {
        case FastNoiseLite.FractalType.FBm:
          return this.GenFractalFBm(x, y, z);
        case FastNoiseLite.FractalType.Ridged:
          return this.GenFractalRidged(x, y, z);
        case FastNoiseLite.FractalType.PingPong:
          return this.GenFractalPingPong(x, y, z);
        default:
          return this.GenNoiseSingle(this.mSeed, x, y, z);
      }
    }

    //[MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public void DomainWarp(ref float x, ref float y)
    {
      switch (this.mFractalType)
      {
        case FastNoiseLite.FractalType.DomainWarpProgressive:
          this.DomainWarpFractalProgressive(ref x, ref y);
          break;
        case FastNoiseLite.FractalType.DomainWarpIndependent:
          this.DomainWarpFractalIndependent(ref x, ref y);
          break;
        default:
          this.DomainWarpSingle(ref x, ref y);
          break;
      }
    }

    //[MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public void DomainWarp(ref float x, ref float y, ref float z)
    {
      switch (this.mFractalType)
      {
        case FastNoiseLite.FractalType.DomainWarpProgressive:
          this.DomainWarpFractalProgressive(ref x, ref y, ref z);
          break;
        case FastNoiseLite.FractalType.DomainWarpIndependent:
          this.DomainWarpFractalIndependent(ref x, ref y, ref z);
          break;
        default:
          this.DomainWarpSingle(ref x, ref y, ref z);
          break;
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float FastMin(float a, float b) => (double) a >= (double) b ? b : a;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float FastMax(float a, float b) => (double) a <= (double) b ? b : a;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float FastAbs(float f) => (double) f >= 0.0 ? f : -f;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float FastSqrt(float f) => (float) Math.Sqrt((double) f);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int FastFloor(float f) => (double) f < 0.0 ? (int) f - 1 : (int) f;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int FastRound(float f)
    {
      return (double) f < 0.0 ? (int) ((double) f - 0.5) : (int) ((double) f + 0.5);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float Lerp(float a, float b, float t) => a + t * (b - a);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float InterpHermite(float t)
    {
      return (float) ((double) t * (double) t * (3.0 - 2.0 * (double) t));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float InterpQuintic(float t)
    {
      return (float) ((double) t * (double) t * (double) t * ((double) t * ((double) t * 6.0 - 15.0) + 10.0));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float CubicLerp(float a, float b, float c, float d, float t)
    {
      float num = (float) ((double) d - (double) c - ((double) a - (double) b));
      return (float) ((double) t * (double) t * (double) t * (double) num + (double) t * (double) t * ((double) a - (double) b - (double) num) + (double) t * ((double) c - (double) a)) + b;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float PingPong(float t)
    {
      t -= (float) ((int) ((double) t * 0.5) * 2);
      return (double) t >= 1.0 ? 2f - t : t;
    }

    private void CalculateFractalBounding()
    {
      float num1 = FastNoiseLite.FastAbs(this.mGain);
      float num2 = num1;
      float num3 = 1f;
      for (int index = 1; index < this.mOctaves; ++index)
      {
        num3 += num2;
        num2 *= num1;
      }
      this.mFractalBounding = 1f / num3;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int Hash(int seed, int xPrimed, int yPrimed)
    {
      return (seed ^ xPrimed ^ yPrimed) * 668265261;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int Hash(int seed, int xPrimed, int yPrimed, int zPrimed)
    {
      return (seed ^ xPrimed ^ yPrimed ^ zPrimed) * 668265261;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float ValCoord(int seed, int xPrimed, int yPrimed)
    {
      int num1 = FastNoiseLite.Hash(seed, xPrimed, yPrimed);
      int num2 = num1 * num1;
      return (float) (num2 ^ num2 << 19) * 4.656613E-10f;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float ValCoord(int seed, int xPrimed, int yPrimed, int zPrimed)
    {
      int num1 = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed);
      int num2 = num1 * num1;
      return (float) (num2 ^ num2 << 19) * 4.656613E-10f;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float GradCoord(int seed, int xPrimed, int yPrimed, float xd, float yd)
    {
      int num1 = FastNoiseLite.Hash(seed, xPrimed, yPrimed);
      int index = (num1 ^ num1 >> 15) & 254;
      float num2 = FastNoiseLite.Gradients2D[index];
      float num3 = FastNoiseLite.Gradients2D[index | 1];
      return (float) ((double) xd * (double) num2 + (double) yd * (double) num3);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float GradCoord(
      int seed,
      int xPrimed,
      int yPrimed,
      int zPrimed,
      float xd,
      float yd,
      float zd)
    {
      int num1 = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed);
      int index = (num1 ^ num1 >> 15) & 252;
      float num2 = FastNoiseLite.Gradients3D[index];
      float num3 = FastNoiseLite.Gradients3D[index | 1];
      float num4 = FastNoiseLite.Gradients3D[index | 2];
      return (float) ((double) xd * (double) num2 + (double) yd * (double) num3 + (double) zd * (double) num4);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GradCoordOut(
      int seed,
      int xPrimed,
      int yPrimed,
      out float xo,
      out float yo)
    {
      int index = FastNoiseLite.Hash(seed, xPrimed, yPrimed) & 510;
      xo = FastNoiseLite.RandVecs2D[index];
      yo = FastNoiseLite.RandVecs2D[index | 1];
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GradCoordOut(
      int seed,
      int xPrimed,
      int yPrimed,
      int zPrimed,
      out float xo,
      out float yo,
      out float zo)
    {
      int index = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed) & 1020;
      xo = FastNoiseLite.RandVecs3D[index];
      yo = FastNoiseLite.RandVecs3D[index | 1];
      zo = FastNoiseLite.RandVecs3D[index | 2];
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GradCoordDual(
      int seed,
      int xPrimed,
      int yPrimed,
      float xd,
      float yd,
      out float xo,
      out float yo)
    {
      int num1 = FastNoiseLite.Hash(seed, xPrimed, yPrimed);
      int index1 = num1 & 254;
      int index2 = num1 >> 7 & 510;
      float num2 = FastNoiseLite.Gradients2D[index1];
      float num3 = FastNoiseLite.Gradients2D[index1 | 1];
      float num4 = (float) ((double) xd * (double) num2 + (double) yd * (double) num3);
      float num5 = FastNoiseLite.RandVecs2D[index2];
      float num6 = FastNoiseLite.RandVecs2D[index2 | 1];
      xo = num4 * num5;
      yo = num4 * num6;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GradCoordDual(
      int seed,
      int xPrimed,
      int yPrimed,
      int zPrimed,
      float xd,
      float yd,
      float zd,
      out float xo,
      out float yo,
      out float zo)
    {
      int num1 = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed);
      int index1 = num1 & 252;
      int index2 = num1 >> 6 & 1020;
      float num2 = FastNoiseLite.Gradients3D[index1];
      float num3 = FastNoiseLite.Gradients3D[index1 | 1];
      float num4 = FastNoiseLite.Gradients3D[index1 | 2];
      float num5 = (float) ((double) xd * (double) num2 + (double) yd * (double) num3 + (double) zd * (double) num4);
      float num6 = FastNoiseLite.RandVecs3D[index2];
      float num7 = FastNoiseLite.RandVecs3D[index2 | 1];
      float num8 = FastNoiseLite.RandVecs3D[index2 | 2];
      xo = num5 * num6;
      yo = num5 * num7;
      zo = num5 * num8;
    }

    private float GenNoiseSingle(int seed, float x, float y)
    {
      switch (this.mNoiseType)
      {
        case FastNoiseLite.NoiseType.OpenSimplex2:
          return this.SingleSimplex(seed, x, y);
        case FastNoiseLite.NoiseType.OpenSimplex2S:
          return this.SingleOpenSimplex2S(seed, x, y);
        case FastNoiseLite.NoiseType.Cellular:
          return this.SingleCellular(seed, x, y);
        case FastNoiseLite.NoiseType.Perlin:
          return this.SinglePerlin(seed, x, y);
        case FastNoiseLite.NoiseType.ValueCubic:
          return this.SingleValueCubic(seed, x, y);
        case FastNoiseLite.NoiseType.Value:
          return this.SingleValue(seed, x, y);
        default:
          return 0.0f;
      }
    }

    private float GenNoiseSingle(int seed, float x, float y, float z)
    {
      switch (this.mNoiseType)
      {
        case FastNoiseLite.NoiseType.OpenSimplex2:
          return this.SingleOpenSimplex2(seed, x, y, z);
        case FastNoiseLite.NoiseType.OpenSimplex2S:
          return this.SingleOpenSimplex2S(seed, x, y, z);
        case FastNoiseLite.NoiseType.Cellular:
          return this.SingleCellular(seed, x, y, z);
        case FastNoiseLite.NoiseType.Perlin:
          return this.SinglePerlin(seed, x, y, z);
        case FastNoiseLite.NoiseType.ValueCubic:
          return this.SingleValueCubic(seed, x, y, z);
        case FastNoiseLite.NoiseType.Value:
          return this.SingleValue(seed, x, y, z);
        default:
          return 0.0f;
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void TransformNoiseCoordinate(ref float x, ref float y)
    {
      x *= this.mFrequency;
      y *= this.mFrequency;
      switch (this.mNoiseType)
      {
        case FastNoiseLite.NoiseType.OpenSimplex2:
        case FastNoiseLite.NoiseType.OpenSimplex2S:
          float num = (float) (((double) x + (double) y) * 0.36602538824081421);
          x += num;
          y += num;
          break;
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void TransformNoiseCoordinate(ref float x, ref float y, ref float z)
    {
      x *= this.mFrequency;
      y *= this.mFrequency;
      z *= this.mFrequency;
      switch (this.mTransformType3D)
      {
        case FastNoiseLite.TransformType3D.ImproveXYPlanes:
          float num1 = x + y;
          float num2 = num1 * -0.211324871f;
          z *= 0.577350259f;
          x += num2 - z;
          y = y + num2 - z;
          z += num1 * 0.577350259f;
          break;
        case FastNoiseLite.TransformType3D.ImproveXZPlanes:
          float num3 = x + z;
          float num4 = num3 * -0.211324871f;
          y *= 0.577350259f;
          x += num4 - y;
          z += num4 - y;
          y += num3 * 0.577350259f;
          break;
        case FastNoiseLite.TransformType3D.DefaultOpenSimplex2:
          float num5 = (float) (((double) x + (double) y + (double) z) * 0.66666668653488159);
          x = num5 - x;
          y = num5 - y;
          z = num5 - z;
          break;
      }
    }

    private void UpdateTransformType3D()
    {
      switch (this.mRotationType3D)
      {
        case FastNoiseLite.RotationType3D.ImproveXYPlanes:
          this.mTransformType3D = FastNoiseLite.TransformType3D.ImproveXYPlanes;
          break;
        case FastNoiseLite.RotationType3D.ImproveXZPlanes:
          this.mTransformType3D = FastNoiseLite.TransformType3D.ImproveXZPlanes;
          break;
        default:
          switch (this.mNoiseType)
          {
            case FastNoiseLite.NoiseType.OpenSimplex2:
            case FastNoiseLite.NoiseType.OpenSimplex2S:
              this.mTransformType3D = FastNoiseLite.TransformType3D.DefaultOpenSimplex2;
              return;
            default:
              this.mTransformType3D = FastNoiseLite.TransformType3D.None;
              return;
          }
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void TransformDomainWarpCoordinate(ref float x, ref float y)
    {
      switch (this.mDomainWarpType)
      {
        case FastNoiseLite.DomainWarpType.OpenSimplex2:
        case FastNoiseLite.DomainWarpType.OpenSimplex2Reduced:
          float num = (float) (((double) x + (double) y) * 0.36602538824081421);
          x += num;
          y += num;
          break;
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void TransformDomainWarpCoordinate(ref float x, ref float y, ref float z)
    {
      switch (this.mWarpTransformType3D)
      {
        case FastNoiseLite.TransformType3D.ImproveXYPlanes:
          float num1 = x + y;
          float num2 = num1 * -0.211324871f;
          z *= 0.577350259f;
          x += num2 - z;
          y = y + num2 - z;
          z += num1 * 0.577350259f;
          break;
        case FastNoiseLite.TransformType3D.ImproveXZPlanes:
          float num3 = x + z;
          float num4 = num3 * -0.211324871f;
          y *= 0.577350259f;
          x += num4 - y;
          z += num4 - y;
          y += num3 * 0.577350259f;
          break;
        case FastNoiseLite.TransformType3D.DefaultOpenSimplex2:
          float num5 = (float) (((double) x + (double) y + (double) z) * 0.66666668653488159);
          x = num5 - x;
          y = num5 - y;
          z = num5 - z;
          break;
      }
    }

    private void UpdateWarpTransformType3D()
    {
      switch (this.mRotationType3D)
      {
        case FastNoiseLite.RotationType3D.ImproveXYPlanes:
          this.mWarpTransformType3D = FastNoiseLite.TransformType3D.ImproveXYPlanes;
          break;
        case FastNoiseLite.RotationType3D.ImproveXZPlanes:
          this.mWarpTransformType3D = FastNoiseLite.TransformType3D.ImproveXZPlanes;
          break;
        default:
          switch (this.mDomainWarpType)
          {
            case FastNoiseLite.DomainWarpType.OpenSimplex2:
            case FastNoiseLite.DomainWarpType.OpenSimplex2Reduced:
              this.mWarpTransformType3D = FastNoiseLite.TransformType3D.DefaultOpenSimplex2;
              return;
            default:
              this.mWarpTransformType3D = FastNoiseLite.TransformType3D.None;
              return;
          }
      }
    }

    private float GenFractalFBm(float x, float y)
    {
      int mSeed = this.mSeed;
      float num1 = 0.0f;
      float num2 = this.mFractalBounding;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float num3 = this.GenNoiseSingle(mSeed++, x, y);
        num1 += num3 * num2;
        float num4 = num2 * FastNoiseLite.Lerp(1f, FastNoiseLite.FastMin(num3 + 1f, 2f) * 0.5f, this.mWeightedStrength);
        x *= this.mLacunarity;
        y *= this.mLacunarity;
        num2 = num4 * this.mGain;
      }
      return num1;
    }

    private float GenFractalFBm(float x, float y, float z)
    {
      int mSeed = this.mSeed;
      float num1 = 0.0f;
      float num2 = this.mFractalBounding;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float num3 = this.GenNoiseSingle(mSeed++, x, y, z);
        num1 += num3 * num2;
        float num4 = num2 * FastNoiseLite.Lerp(1f, (float) (((double) num3 + 1.0) * 0.5), this.mWeightedStrength);
        x *= this.mLacunarity;
        y *= this.mLacunarity;
        z *= this.mLacunarity;
        num2 = num4 * this.mGain;
      }
      return num1;
    }

    private float GenFractalRidged(float x, float y)
    {
      int mSeed = this.mSeed;
      float num1 = 0.0f;
      float num2 = this.mFractalBounding;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float num3 = FastNoiseLite.FastAbs(this.GenNoiseSingle(mSeed++, x, y));
        num1 += (float) ((double) num3 * -2.0 + 1.0) * num2;
        float num4 = num2 * FastNoiseLite.Lerp(1f, 1f - num3, this.mWeightedStrength);
        x *= this.mLacunarity;
        y *= this.mLacunarity;
        num2 = num4 * this.mGain;
      }
      return num1;
    }

    private float GenFractalRidged(float x, float y, float z)
    {
      int mSeed = this.mSeed;
      float num1 = 0.0f;
      float num2 = this.mFractalBounding;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float num3 = FastNoiseLite.FastAbs(this.GenNoiseSingle(mSeed++, x, y, z));
        num1 += (float) ((double) num3 * -2.0 + 1.0) * num2;
        float num4 = num2 * FastNoiseLite.Lerp(1f, 1f - num3, this.mWeightedStrength);
        x *= this.mLacunarity;
        y *= this.mLacunarity;
        z *= this.mLacunarity;
        num2 = num4 * this.mGain;
      }
      return num1;
    }

    private float GenFractalPingPong(float x, float y)
    {
      int mSeed = this.mSeed;
      float num1 = 0.0f;
      float num2 = this.mFractalBounding;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float b = FastNoiseLite.PingPong((this.GenNoiseSingle(mSeed++, x, y) + 1f) * this.mPingPongStrength);
        num1 += (float) (((double) b - 0.5) * 2.0) * num2;
        float num3 = num2 * FastNoiseLite.Lerp(1f, b, this.mWeightedStrength);
        x *= this.mLacunarity;
        y *= this.mLacunarity;
        num2 = num3 * this.mGain;
      }
      return num1;
    }

    private float GenFractalPingPong(float x, float y, float z)
    {
      int mSeed = this.mSeed;
      float num1 = 0.0f;
      float num2 = this.mFractalBounding;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float b = FastNoiseLite.PingPong((this.GenNoiseSingle(mSeed++, x, y, z) + 1f) * this.mPingPongStrength);
        num1 += (float) (((double) b - 0.5) * 2.0) * num2;
        float num3 = num2 * FastNoiseLite.Lerp(1f, b, this.mWeightedStrength);
        x *= this.mLacunarity;
        y *= this.mLacunarity;
        z *= this.mLacunarity;
        num2 = num3 * this.mGain;
      }
      return num1;
    }

    private float SingleSimplex(int seed, float x, float y)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      double num3 = (double) (x - (float) num1);
      float num4 = y - (float) num2;
      float num5 = (float) ((num3 + (double) num4) * 0.21132487058639526);
      float xd1 = (float) num3 - num5;
      float yd1 = num4 - num5;
      int xPrimed = num1 * 501125321;
      int yPrimed = num2 * 1136930381;
      float num6 = (float) (0.5 - (double) xd1 * (double) xd1 - (double) yd1 * (double) yd1);
      float num7 = (double) num6 > 0.0 ? (float) ((double) num6 * (double) num6 * ((double) num6 * (double) num6)) * FastNoiseLite.GradCoord(seed, xPrimed, yPrimed, xd1, yd1) : 0.0f;
      float num8 = (float) (3.1547005176544189 * (double) num5 + ((double) num6 - 0.66666662693023682));
      float num9;
      if ((double) num8 <= 0.0)
      {
        num9 = 0.0f;
      }
      else
      {
        float xd2 = xd1 - 0.577350259f;
        float yd2 = yd1 - 0.577350259f;
        num9 = (float) ((double) num8 * (double) num8 * ((double) num8 * (double) num8)) * FastNoiseLite.GradCoord(seed, xPrimed + 501125321, yPrimed + 1136930381, xd2, yd2);
      }
      float num10;
      if ((double) yd1 > (double) xd1)
      {
        float xd3 = xd1 + 0.211324871f;
        float yd3 = yd1 - 0.7886751f;
        float num11 = (float) (0.5 - (double) xd3 * (double) xd3 - (double) yd3 * (double) yd3);
        num10 = (double) num11 > 0.0 ? (float) ((double) num11 * (double) num11 * ((double) num11 * (double) num11)) * FastNoiseLite.GradCoord(seed, xPrimed, yPrimed + 1136930381, xd3, yd3) : 0.0f;
      }
      else
      {
        float xd4 = xd1 - 0.7886751f;
        float yd4 = yd1 + 0.211324871f;
        float num12 = (float) (0.5 - (double) xd4 * (double) xd4 - (double) yd4 * (double) yd4);
        num10 = (double) num12 > 0.0 ? (float) ((double) num12 * (double) num12 * ((double) num12 * (double) num12)) * FastNoiseLite.GradCoord(seed, xPrimed + 501125321, yPrimed, xd4, yd4) : 0.0f;
      }
      return (float) (((double) num7 + (double) num10 + (double) num9) * 99.83685302734375);
    }

    private float SingleOpenSimplex2(int seed, float x, float y, float z)
    {
      int num1 = FastNoiseLite.FastRound(x);
      int num2 = FastNoiseLite.FastRound(y);
      int num3 = FastNoiseLite.FastRound(z);
      float xd = x - (float) num1;
      float yd = y - (float) num2;
      float zd = z - (float) num3;
      int num4 = (int) (-1.0 - (double) xd) | 1;
      int num5 = (int) (-1.0 - (double) yd) | 1;
      int num6 = (int) (-1.0 - (double) zd) | 1;
      float num7 = (float) num4 * -xd;
      float num8 = (float) num5 * -yd;
      float num9 = (float) num6 * -zd;
      int xPrimed = num1 * 501125321;
      int yPrimed = num2 * 1136930381;
      int zPrimed = num3 * 1720413743;
      float num10 = 0.0f;
      float num11 = (float) (0.60000002384185791 - (double) xd * (double) xd - ((double) yd * (double) yd + (double) zd * (double) zd));
      int num12 = 0;
      while (true)
      {
        if ((double) num11 > 0.0)
          num10 += (float) ((double) num11 * (double) num11 * ((double) num11 * (double) num11)) * FastNoiseLite.GradCoord(seed, xPrimed, yPrimed, zPrimed, xd, yd, zd);
        if ((double) num7 >= (double) num8 && (double) num7 >= (double) num9)
        {
          float num13 = num11 + num7 + num7;
          if ((double) num13 > 1.0)
          {
            float num14 = num13 - 1f;
            num10 += (float) ((double) num14 * (double) num14 * ((double) num14 * (double) num14)) * FastNoiseLite.GradCoord(seed, xPrimed - num4 * 501125321, yPrimed, zPrimed, xd + (float) num4, yd, zd);
          }
        }
        else if ((double) num8 > (double) num7 && (double) num8 >= (double) num9)
        {
          float num15 = num11 + num8 + num8;
          if ((double) num15 > 1.0)
          {
            float num16 = num15 - 1f;
            num10 += (float) ((double) num16 * (double) num16 * ((double) num16 * (double) num16)) * FastNoiseLite.GradCoord(seed, xPrimed, yPrimed - num5 * 1136930381, zPrimed, xd, yd + (float) num5, zd);
          }
        }
        else
        {
          float num17 = num11 + num9 + num9;
          if ((double) num17 > 1.0)
          {
            float num18 = num17 - 1f;
            num10 += (float) ((double) num18 * (double) num18 * ((double) num18 * (double) num18)) * FastNoiseLite.GradCoord(seed, xPrimed, yPrimed, zPrimed - num6 * 1720413743, xd, yd, zd + (float) num6);
          }
        }
        if (num12 != 1)
        {
          num7 = 0.5f - num7;
          num8 = 0.5f - num8;
          num9 = 0.5f - num9;
          xd = (float) num4 * num7;
          yd = (float) num5 * num8;
          zd = (float) num6 * num9;
          num11 += (float) (0.75 - (double) num7 - ((double) num8 + (double) num9));
          xPrimed += num4 >> 1 & 501125321;
          yPrimed += num5 >> 1 & 1136930381;
          zPrimed += num6 >> 1 & 1720413743;
          num4 = -num4;
          num5 = -num5;
          num6 = -num6;
          seed = ~seed;
          ++num12;
        }
        else
          break;
      }
      return num10 * 32.6942825f;
    }

    private float SingleOpenSimplex2S(int seed, float x, float y)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      float num3 = x - (float) num1;
      float num4 = y - (float) num2;
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      float num5 = (float) (((double) num3 + (double) num4) * 0.21132487058639526);
      float xd1 = num3 - num5;
      float yd1 = num4 - num5;
      float num6 = (float) (0.66666668653488159 - (double) xd1 * (double) xd1 - (double) yd1 * (double) yd1);
      float num7 = (float) ((double) num6 * (double) num6 * ((double) num6 * (double) num6)) * FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1, xd1, yd1);
      float num8 = (float) (3.1547005176544189 * (double) num5 + ((double) num6 - 0.66666662693023682));
      float xd2 = xd1 - 0.577350259f;
      float yd2 = yd1 - 0.577350259f;
      float num9 = num7 + (float) ((double) num8 * (double) num8 * ((double) num8 * (double) num8)) * FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed2, xd2, yd2);
      float num10 = num3 - num4;
      if ((double) num5 > 0.21132487058639526)
      {
        if ((double) num3 + (double) num10 > 1.0)
        {
          float xd3 = xd1 - 1.36602545f;
          float yd3 = yd1 - 0.3660254f;
          float num11 = (float) (0.66666668653488159 - (double) xd3 * (double) xd3 - (double) yd3 * (double) yd3);
          if ((double) num11 > 0.0)
            num9 += (float) ((double) num11 * (double) num11 * ((double) num11 * (double) num11)) * FastNoiseLite.GradCoord(seed, xPrimed1 + 1002250642, yPrimed1 + 1136930381, xd3, yd3);
        }
        else
        {
          float xd4 = xd1 + 0.211324871f;
          float yd4 = yd1 - 0.7886751f;
          float num12 = (float) (0.66666668653488159 - (double) xd4 * (double) xd4 - (double) yd4 * (double) yd4);
          if ((double) num12 > 0.0)
            num9 += (float) ((double) num12 * (double) num12 * ((double) num12 * (double) num12)) * FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1 + 1136930381, xd4, yd4);
        }
        if ((double) num4 - (double) num10 > 1.0)
        {
          float xd5 = xd1 - 0.3660254f;
          float yd5 = yd1 - 1.36602545f;
          float num13 = (float) (0.66666668653488159 - (double) xd5 * (double) xd5 - (double) yd5 * (double) yd5);
          if ((double) num13 > 0.0)
            num9 += (float) ((double) num13 * (double) num13 * ((double) num13 * (double) num13)) * FastNoiseLite.GradCoord(seed, xPrimed1 + 501125321, yPrimed1 - 2021106534, xd5, yd5);
        }
        else
        {
          float xd6 = xd1 - 0.7886751f;
          float yd6 = yd1 + 0.211324871f;
          float num14 = (float) (0.66666668653488159 - (double) xd6 * (double) xd6 - (double) yd6 * (double) yd6);
          if ((double) num14 > 0.0)
            num9 += (float) ((double) num14 * (double) num14 * ((double) num14 * (double) num14)) * FastNoiseLite.GradCoord(seed, xPrimed1 + 501125321, yPrimed1, xd6, yd6);
        }
      }
      else
      {
        if ((double) num3 + (double) num10 < 0.0)
        {
          float xd7 = xd1 + 0.7886751f;
          float yd7 = yd1 - 0.211324871f;
          float num15 = (float) (0.66666668653488159 - (double) xd7 * (double) xd7 - (double) yd7 * (double) yd7);
          if ((double) num15 > 0.0)
            num9 += (float) ((double) num15 * (double) num15 * ((double) num15 * (double) num15)) * FastNoiseLite.GradCoord(seed, xPrimed1 - 501125321, yPrimed1, xd7, yd7);
        }
        else
        {
          float xd8 = xd1 - 0.7886751f;
          float yd8 = yd1 + 0.211324871f;
          float num16 = (float) (0.66666668653488159 - (double) xd8 * (double) xd8 - (double) yd8 * (double) yd8);
          if ((double) num16 > 0.0)
            num9 += (float) ((double) num16 * (double) num16 * ((double) num16 * (double) num16)) * FastNoiseLite.GradCoord(seed, xPrimed1 + 501125321, yPrimed1, xd8, yd8);
        }
        if ((double) num4 < (double) num10)
        {
          float xd9 = xd1 - 0.211324871f;
          float yd9 = yd1 - -0.7886751f;
          float num17 = (float) (0.66666668653488159 - (double) xd9 * (double) xd9 - (double) yd9 * (double) yd9);
          if ((double) num17 > 0.0)
            num9 += (float) ((double) num17 * (double) num17 * ((double) num17 * (double) num17)) * FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1 - 1136930381, xd9, yd9);
        }
        else
        {
          float xd10 = xd1 + 0.211324871f;
          float yd10 = yd1 - 0.7886751f;
          float num18 = (float) (0.66666668653488159 - (double) xd10 * (double) xd10 - (double) yd10 * (double) yd10);
          if ((double) num18 > 0.0)
            num9 += (float) ((double) num18 * (double) num18 * ((double) num18 * (double) num18)) * FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1 + 1136930381, xd10, yd10);
        }
      }
      return num9 * 18.2419624f;
    }

    private float SingleOpenSimplex2S(int seed, float x, float y, float z)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      int num3 = FastNoiseLite.FastFloor(z);
      float num4 = x - (float) num1;
      float num5 = y - (float) num2;
      float num6 = z - (float) num3;
      int num7 = num1 * 501125321;
      int num8 = num2 * 1136930381;
      int num9 = num3 * 1720413743;
      int seed1 = seed + 1293373;
      int num10 = (int) (-0.5 - (double) num4);
      int num11 = (int) (-0.5 - (double) num5);
      int num12 = (int) (-0.5 - (double) num6);
      float xd1 = num4 + (float) num10;
      float yd1 = num5 + (float) num11;
      float zd1 = num6 + (float) num12;
      float num13 = (float) (0.75 - (double) xd1 * (double) xd1 - (double) yd1 * (double) yd1 - (double) zd1 * (double) zd1);
      float num14 = (float) ((double) num13 * (double) num13 * ((double) num13 * (double) num13)) * FastNoiseLite.GradCoord(seed, num7 + (num10 & 501125321), num8 + (num11 & 1136930381), num9 + (num12 & 1720413743), xd1, yd1, zd1);
      float xd2 = num4 - 0.5f;
      float yd2 = num5 - 0.5f;
      float zd2 = num6 - 0.5f;
      float num15 = (float) (0.75 - (double) xd2 * (double) xd2 - (double) yd2 * (double) yd2 - (double) zd2 * (double) zd2);
      float num16 = num14 + (float) ((double) num15 * (double) num15 * ((double) num15 * (double) num15)) * FastNoiseLite.GradCoord(seed1, num7 + 501125321, num8 + 1136930381, num9 + 1720413743, xd2, yd2, zd2);
      float num17 = (float) ((num10 | 1) << 1) * xd2;
      float num18 = (float) ((num11 | 1) << 1) * yd2;
      float num19 = (float) ((num12 | 1) << 1) * zd2;
      float num20 = (float) ((double) (-2 - (num10 << 2)) * (double) xd2 - 1.0);
      float num21 = (float) ((double) (-2 - (num11 << 2)) * (double) yd2 - 1.0);
      float num22 = (float) ((double) (-2 - (num12 << 2)) * (double) zd2 - 1.0);
      bool flag1 = false;
      float num23 = num17 + num13;
      if ((double) num23 > 0.0)
      {
        float xd3 = xd1 - (float) (num10 | 1);
        float yd3 = yd1;
        float zd3 = zd1;
        num16 += (float) ((double) num23 * (double) num23 * ((double) num23 * (double) num23)) * FastNoiseLite.GradCoord(seed, num7 + (~num10 & 501125321), num8 + (num11 & 1136930381), num9 + (num12 & 1720413743), xd3, yd3, zd3);
      }
      else
      {
        float num24 = num18 + num19 + num13;
        if ((double) num24 > 0.0)
        {
          float xd4 = xd1;
          float yd4 = yd1 - (float) (num11 | 1);
          float zd4 = zd1 - (float) (num12 | 1);
          num16 += (float) ((double) num24 * (double) num24 * ((double) num24 * (double) num24)) * FastNoiseLite.GradCoord(seed, num7 + (num10 & 501125321), num8 + (~num11 & 1136930381), num9 + (~num12 & 1720413743), xd4, yd4, zd4);
        }
        float num25 = num20 + num15;
        if ((double) num25 > 0.0)
        {
          float xd5 = (float) (num10 | 1) + xd2;
          float yd5 = yd2;
          float zd5 = zd2;
          num16 += (float) ((double) num25 * (double) num25 * ((double) num25 * (double) num25)) * FastNoiseLite.GradCoord(seed1, num7 + (num10 & 1002250642), num8 + 1136930381, num9 + 1720413743, xd5, yd5, zd5);
          flag1 = true;
        }
      }
      bool flag2 = false;
      float num26 = num18 + num13;
      if ((double) num26 > 0.0)
      {
        float xd6 = xd1;
        float yd6 = yd1 - (float) (num11 | 1);
        float zd6 = zd1;
        num16 += (float) ((double) num26 * (double) num26 * ((double) num26 * (double) num26)) * FastNoiseLite.GradCoord(seed, num7 + (num10 & 501125321), num8 + (~num11 & 1136930381), num9 + (num12 & 1720413743), xd6, yd6, zd6);
      }
      else
      {
        float num27 = num17 + num19 + num13;
        if ((double) num27 > 0.0)
        {
          float xd7 = xd1 - (float) (num10 | 1);
          float yd7 = yd1;
          float zd7 = zd1 - (float) (num12 | 1);
          num16 += (float) ((double) num27 * (double) num27 * ((double) num27 * (double) num27)) * FastNoiseLite.GradCoord(seed, num7 + (~num10 & 501125321), num8 + (num11 & 1136930381), num9 + (~num12 & 1720413743), xd7, yd7, zd7);
        }
        float num28 = num21 + num15;
        if ((double) num28 > 0.0)
        {
          float xd8 = xd2;
          float yd8 = (float) (num11 | 1) + yd2;
          float zd8 = zd2;
          num16 += (float) ((double) num28 * (double) num28 * ((double) num28 * (double) num28)) * FastNoiseLite.GradCoord(seed1, num7 + 501125321, num8 + (num11 & -2021106534), num9 + 1720413743, xd8, yd8, zd8);
          flag2 = true;
        }
      }
      bool flag3 = false;
      float num29 = num19 + num13;
      if ((double) num29 > 0.0)
      {
        float xd9 = xd1;
        float yd9 = yd1;
        float zd9 = zd1 - (float) (num12 | 1);
        num16 += (float) ((double) num29 * (double) num29 * ((double) num29 * (double) num29)) * FastNoiseLite.GradCoord(seed, num7 + (num10 & 501125321), num8 + (num11 & 1136930381), num9 + (~num12 & 1720413743), xd9, yd9, zd9);
      }
      else
      {
        float num30 = num17 + num18 + num13;
        if ((double) num30 > 0.0)
        {
          float xd10 = xd1 - (float) (num10 | 1);
          float yd10 = yd1 - (float) (num11 | 1);
          float zd10 = zd1;
          num16 += (float) ((double) num30 * (double) num30 * ((double) num30 * (double) num30)) * FastNoiseLite.GradCoord(seed, num7 + (~num10 & 501125321), num8 + (~num11 & 1136930381), num9 + (num12 & 1720413743), xd10, yd10, zd10);
        }
        float num31 = num22 + num15;
        if ((double) num31 > 0.0)
        {
          float xd11 = xd2;
          float yd11 = yd2;
          float zd11 = (float) (num12 | 1) + zd2;
          num16 += (float) ((double) num31 * (double) num31 * ((double) num31 * (double) num31)) * FastNoiseLite.GradCoord(seed1, num7 + 501125321, num8 + 1136930381, num9 + (num12 & -854139810), xd11, yd11, zd11);
          flag3 = true;
        }
      }
      if (!flag1)
      {
        float num32 = num21 + num22 + num15;
        if ((double) num32 > 0.0)
        {
          float xd12 = xd2;
          float yd12 = (float) (num11 | 1) + yd2;
          float zd12 = (float) (num12 | 1) + zd2;
          num16 += (float) ((double) num32 * (double) num32 * ((double) num32 * (double) num32)) * FastNoiseLite.GradCoord(seed1, num7 + 501125321, num8 + (num11 & -2021106534), num9 + (num12 & -854139810), xd12, yd12, zd12);
        }
      }
      if (!flag2)
      {
        float num33 = num20 + num22 + num15;
        if ((double) num33 > 0.0)
        {
          float xd13 = (float) (num10 | 1) + xd2;
          float yd13 = yd2;
          float zd13 = (float) (num12 | 1) + zd2;
          num16 += (float) ((double) num33 * (double) num33 * ((double) num33 * (double) num33)) * FastNoiseLite.GradCoord(seed1, num7 + (num10 & 1002250642), num8 + 1136930381, num9 + (num12 & -854139810), xd13, yd13, zd13);
        }
      }
      if (!flag3)
      {
        float num34 = num20 + num21 + num15;
        if ((double) num34 > 0.0)
        {
          float xd14 = (float) (num10 | 1) + xd2;
          float yd14 = (float) (num11 | 1) + yd2;
          float zd14 = zd2;
          num16 += (float) ((double) num34 * (double) num34 * ((double) num34 * (double) num34)) * FastNoiseLite.GradCoord(seed1, num7 + (num10 & 1002250642), num8 + (num11 & -2021106534), num9 + 1720413743, xd14, yd14, zd14);
        }
      }
      return num16 * 9.046026f;
    }

    private float SingleCellular(int seed, float x, float y)
    {
      int num1 = FastNoiseLite.FastRound(x);
      int num2 = FastNoiseLite.FastRound(y);
      float num3 = float.MaxValue;
      float num4 = float.MaxValue;
      int num5 = 0;
      float num6 = 0.437015951f * this.mCellularJitterModifier;
      int xPrimed = (num1 - 1) * 501125321;
      int num7 = (num2 - 1) * 1136930381;
      switch (this.mCellularDistanceFunction)
      {
        case FastNoiseLite.CellularDistanceFunction.Manhattan:
          for (int index1 = num1 - 1; index1 <= num1 + 1; ++index1)
          {
            int yPrimed = num7;
            for (int index2 = num2 - 1; index2 <= num2 + 1; ++index2)
            {
              int num8 = FastNoiseLite.Hash(seed, xPrimed, yPrimed);
              int index3 = num8 & 510;
              double f1 = (double) ((float) index1 - x) + (double) FastNoiseLite.RandVecs2D[index3] * (double) num6;
              float f2 = (float) index2 - y + FastNoiseLite.RandVecs2D[index3 | 1] * num6;
              float b = FastNoiseLite.FastAbs((float) f1) + FastNoiseLite.FastAbs(f2);
              num4 = FastNoiseLite.FastMax(FastNoiseLite.FastMin(num4, b), num3);
              if ((double) b < (double) num3)
              {
                num3 = b;
                num5 = num8;
              }
              yPrimed += 1136930381;
            }
            xPrimed += 501125321;
          }
          break;
        case FastNoiseLite.CellularDistanceFunction.Hybrid:
          for (int index4 = num1 - 1; index4 <= num1 + 1; ++index4)
          {
            int yPrimed = num7;
            for (int index5 = num2 - 1; index5 <= num2 + 1; ++index5)
            {
              int num9 = FastNoiseLite.Hash(seed, xPrimed, yPrimed);
              int index6 = num9 & 510;
              float f3 = (float) index4 - x + FastNoiseLite.RandVecs2D[index6] * num6;
              float f4 = (float) index5 - y + FastNoiseLite.RandVecs2D[index6 | 1] * num6;
              float b = (float) ((double) FastNoiseLite.FastAbs(f3) + (double) FastNoiseLite.FastAbs(f4) + ((double) f3 * (double) f3 + (double) f4 * (double) f4));
              num4 = FastNoiseLite.FastMax(FastNoiseLite.FastMin(num4, b), num3);
              if ((double) b < (double) num3)
              {
                num3 = b;
                num5 = num9;
              }
              yPrimed += 1136930381;
            }
            xPrimed += 501125321;
          }
          break;
        default:
          for (int index7 = num1 - 1; index7 <= num1 + 1; ++index7)
          {
            int yPrimed = num7;
            for (int index8 = num2 - 1; index8 <= num2 + 1; ++index8)
            {
              int num10 = FastNoiseLite.Hash(seed, xPrimed, yPrimed);
              int index9 = num10 & 510;
              double num11 = (double) ((float) index7 - x) + (double) FastNoiseLite.RandVecs2D[index9] * (double) num6;
              float num12 = (float) index8 - y + FastNoiseLite.RandVecs2D[index9 | 1] * num6;
              float b = (float) (num11 * num11 + (double) num12 * (double) num12);
              num4 = FastNoiseLite.FastMax(FastNoiseLite.FastMin(num4, b), num3);
              if ((double) b < (double) num3)
              {
                num3 = b;
                num5 = num10;
              }
              yPrimed += 1136930381;
            }
            xPrimed += 501125321;
          }
          break;
      }
      if (this.mCellularDistanceFunction == FastNoiseLite.CellularDistanceFunction.Euclidean && this.mCellularReturnType >= FastNoiseLite.CellularReturnType.Distance)
      {
        num3 = FastNoiseLite.FastSqrt(num3);
        if (this.mCellularReturnType >= FastNoiseLite.CellularReturnType.Distance2)
          num4 = FastNoiseLite.FastSqrt(num4);
      }
      switch (this.mCellularReturnType)
      {
        case FastNoiseLite.CellularReturnType.CellValue:
          return (float) num5 * 4.656613E-10f;
        case FastNoiseLite.CellularReturnType.Distance:
          return num3 - 1f;
        case FastNoiseLite.CellularReturnType.Distance2:
          return num4 - 1f;
        case FastNoiseLite.CellularReturnType.Distance2Add:
          return (float) (((double) num4 + (double) num3) * 0.5 - 1.0);
        case FastNoiseLite.CellularReturnType.Distance2Sub:
          return (float) ((double) num4 - (double) num3 - 1.0);
        case FastNoiseLite.CellularReturnType.Distance2Mul:
          return (float) ((double) num4 * (double) num3 * 0.5 - 1.0);
        case FastNoiseLite.CellularReturnType.Distance2Div:
          return (float) ((double) num3 / (double) num4 - 1.0);
        default:
          return 0.0f;
      }
    }

    private float SingleCellular(int seed, float x, float y, float z)
    {
      int num1 = FastNoiseLite.FastRound(x);
      int num2 = FastNoiseLite.FastRound(y);
      int num3 = FastNoiseLite.FastRound(z);
      float num4 = float.MaxValue;
      float num5 = float.MaxValue;
      int num6 = 0;
      float num7 = 0.396143526f * this.mCellularJitterModifier;
      int xPrimed = (num1 - 1) * 501125321;
      int num8 = (num2 - 1) * 1136930381;
      int num9 = (num3 - 1) * 1720413743;
      switch (this.mCellularDistanceFunction)
      {
        case FastNoiseLite.CellularDistanceFunction.Euclidean:
        case FastNoiseLite.CellularDistanceFunction.EuclideanSq:
          for (int index1 = num1 - 1; index1 <= num1 + 1; ++index1)
          {
            int yPrimed = num8;
            for (int index2 = num2 - 1; index2 <= num2 + 1; ++index2)
            {
              int zPrimed = num9;
              for (int index3 = num3 - 1; index3 <= num3 + 1; ++index3)
              {
                int num10 = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed);
                int index4 = num10 & 1020;
                double num11 = (double) ((float) index1 - x) + (double) FastNoiseLite.RandVecs3D[index4] * (double) num7;
                float num12 = (float) index2 - y + FastNoiseLite.RandVecs3D[index4 | 1] * num7;
                float num13 = (float) index3 - z + FastNoiseLite.RandVecs3D[index4 | 2] * num7;
                float b = (float) (num11 * num11 + (double) num12 * (double) num12 + (double) num13 * (double) num13);
                num5 = FastNoiseLite.FastMax(FastNoiseLite.FastMin(num5, b), num4);
                if ((double) b < (double) num4)
                {
                  num4 = b;
                  num6 = num10;
                }
                zPrimed += 1720413743;
              }
              yPrimed += 1136930381;
            }
            xPrimed += 501125321;
          }
          break;
        case FastNoiseLite.CellularDistanceFunction.Manhattan:
          for (int index5 = num1 - 1; index5 <= num1 + 1; ++index5)
          {
            int yPrimed = num8;
            for (int index6 = num2 - 1; index6 <= num2 + 1; ++index6)
            {
              int zPrimed = num9;
              for (int index7 = num3 - 1; index7 <= num3 + 1; ++index7)
              {
                int num14 = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed);
                int index8 = num14 & 1020;
                double f1 = (double) ((float) index5 - x) + (double) FastNoiseLite.RandVecs3D[index8] * (double) num7;
                float f2 = (float) index6 - y + FastNoiseLite.RandVecs3D[index8 | 1] * num7;
                float f3 = (float) index7 - z + FastNoiseLite.RandVecs3D[index8 | 2] * num7;
                float b = FastNoiseLite.FastAbs((float) f1) + FastNoiseLite.FastAbs(f2) + FastNoiseLite.FastAbs(f3);
                num5 = FastNoiseLite.FastMax(FastNoiseLite.FastMin(num5, b), num4);
                if ((double) b < (double) num4)
                {
                  num4 = b;
                  num6 = num14;
                }
                zPrimed += 1720413743;
              }
              yPrimed += 1136930381;
            }
            xPrimed += 501125321;
          }
          break;
        case FastNoiseLite.CellularDistanceFunction.Hybrid:
          for (int index9 = num1 - 1; index9 <= num1 + 1; ++index9)
          {
            int yPrimed = num8;
            for (int index10 = num2 - 1; index10 <= num2 + 1; ++index10)
            {
              int zPrimed = num9;
              for (int index11 = num3 - 1; index11 <= num3 + 1; ++index11)
              {
                int num15 = FastNoiseLite.Hash(seed, xPrimed, yPrimed, zPrimed);
                int index12 = num15 & 1020;
                float f4 = (float) index9 - x + FastNoiseLite.RandVecs3D[index12] * num7;
                float f5 = (float) index10 - y + FastNoiseLite.RandVecs3D[index12 | 1] * num7;
                float f6 = (float) index11 - z + FastNoiseLite.RandVecs3D[index12 | 2] * num7;
                float b = (float) ((double) FastNoiseLite.FastAbs(f4) + (double) FastNoiseLite.FastAbs(f5) + (double) FastNoiseLite.FastAbs(f6) + ((double) f4 * (double) f4 + (double) f5 * (double) f5 + (double) f6 * (double) f6));
                num5 = FastNoiseLite.FastMax(FastNoiseLite.FastMin(num5, b), num4);
                if ((double) b < (double) num4)
                {
                  num4 = b;
                  num6 = num15;
                }
                zPrimed += 1720413743;
              }
              yPrimed += 1136930381;
            }
            xPrimed += 501125321;
          }
          break;
      }
      if (this.mCellularDistanceFunction == FastNoiseLite.CellularDistanceFunction.Euclidean && this.mCellularReturnType >= FastNoiseLite.CellularReturnType.Distance)
      {
        num4 = FastNoiseLite.FastSqrt(num4);
        if (this.mCellularReturnType >= FastNoiseLite.CellularReturnType.Distance2)
          num5 = FastNoiseLite.FastSqrt(num5);
      }
      switch (this.mCellularReturnType)
      {
        case FastNoiseLite.CellularReturnType.CellValue:
          return (float) num6 * 4.656613E-10f;
        case FastNoiseLite.CellularReturnType.Distance:
          return num4 - 1f;
        case FastNoiseLite.CellularReturnType.Distance2:
          return num5 - 1f;
        case FastNoiseLite.CellularReturnType.Distance2Add:
          return (float) (((double) num5 + (double) num4) * 0.5 - 1.0);
        case FastNoiseLite.CellularReturnType.Distance2Sub:
          return (float) ((double) num5 - (double) num4 - 1.0);
        case FastNoiseLite.CellularReturnType.Distance2Mul:
          return (float) ((double) num5 * (double) num4 * 0.5 - 1.0);
        case FastNoiseLite.CellularReturnType.Distance2Div:
          return (float) ((double) num4 / (double) num5 - 1.0);
        default:
          return 0.0f;
      }
    }

    private float SinglePerlin(int seed, float x, float y)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      float num3 = x - (float) num1;
      float num4 = y - (float) num2;
      float xd = num3 - 1f;
      float yd = num4 - 1f;
      float t1 = FastNoiseLite.InterpQuintic(num3);
      float t2 = FastNoiseLite.InterpQuintic(num4);
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      return FastNoiseLite.Lerp(FastNoiseLite.Lerp(FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1, num3, num4), FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed1, xd, num4), t1), FastNoiseLite.Lerp(FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed2, num3, yd), FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed2, xd, yd), t1), t2) * 1.42476916f;
    }

    private float SinglePerlin(int seed, float x, float y, float z)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      int num3 = FastNoiseLite.FastFloor(z);
      float num4 = x - (float) num1;
      float num5 = y - (float) num2;
      float num6 = z - (float) num3;
      float xd = num4 - 1f;
      float yd = num5 - 1f;
      float zd = num6 - 1f;
      float t1 = FastNoiseLite.InterpQuintic(num4);
      float t2 = FastNoiseLite.InterpQuintic(num5);
      float t3 = FastNoiseLite.InterpQuintic(num6);
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int zPrimed1 = num3 * 1720413743;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      int zPrimed2 = zPrimed1 + 1720413743;
      double a1 = (double) FastNoiseLite.Lerp(FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1, zPrimed1, num4, num5, num6), FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed1, zPrimed1, xd, num5, num6), t1);
      float num7 = FastNoiseLite.Lerp(FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed2, zPrimed1, num4, yd, num6), FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed2, zPrimed1, xd, yd, num6), t1);
      float a2 = FastNoiseLite.Lerp(FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed1, zPrimed2, num4, num5, zd), FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed1, zPrimed2, xd, num5, zd), t1);
      float b1 = FastNoiseLite.Lerp(FastNoiseLite.GradCoord(seed, xPrimed1, yPrimed2, zPrimed2, num4, yd, zd), FastNoiseLite.GradCoord(seed, xPrimed2, yPrimed2, zPrimed2, xd, yd, zd), t1);
      double b2 = (double) num7;
      double t4 = (double) t2;
      return FastNoiseLite.Lerp(FastNoiseLite.Lerp((float) a1, (float) b2, (float) t4), FastNoiseLite.Lerp(a2, b1, t2), t3) * 0.9649214f;
    }

    private float SingleValueCubic(int seed, float x, float y)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      float t1 = x - (float) num1;
      float t2 = y - (float) num2;
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int xPrimed2 = xPrimed1 - 501125321;
      int yPrimed2 = yPrimed1 - 1136930381;
      int xPrimed3 = xPrimed1 + 501125321;
      int yPrimed3 = yPrimed1 + 1136930381;
      int xPrimed4 = xPrimed1 + 1002250642;
      int yPrimed4 = yPrimed1 - 2021106534;
      return FastNoiseLite.CubicLerp(FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed2), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed2), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed1), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed1), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed3), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed3), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed3), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed3), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed4), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed4), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed4), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed4), t1), t2) * 0.444444448f;
    }

    private float SingleValueCubic(int seed, float x, float y, float z)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      int num3 = FastNoiseLite.FastFloor(z);
      float t1 = x - (float) num1;
      float t2 = y - (float) num2;
      float t3 = z - (float) num3;
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int zPrimed1 = num3 * 1720413743;
      int xPrimed2 = xPrimed1 - 501125321;
      int yPrimed2 = yPrimed1 - 1136930381;
      int zPrimed2 = zPrimed1 - 1720413743;
      int xPrimed3 = xPrimed1 + 501125321;
      int yPrimed3 = yPrimed1 + 1136930381;
      int zPrimed3 = zPrimed1 + 1720413743;
      int xPrimed4 = xPrimed1 + 1002250642;
      int yPrimed4 = yPrimed1 - 2021106534;
      int zPrimed4 = zPrimed1 - 854139810;
      return FastNoiseLite.CubicLerp(FastNoiseLite.CubicLerp(FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed2, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed2, zPrimed2), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed1, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed1, zPrimed2), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed3, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed3, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed3, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed3, zPrimed2), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed4, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed4, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed4, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed4, zPrimed2), t1), t2), FastNoiseLite.CubicLerp(FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed2, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed2, zPrimed1), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed1, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed1, zPrimed1), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed3, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed3, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed3, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed3, zPrimed1), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed4, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed4, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed4, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed4, zPrimed1), t1), t2), FastNoiseLite.CubicLerp(FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed2, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed2, zPrimed3), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed1, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed1, zPrimed3), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed3, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed3, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed3, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed3, zPrimed3), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed4, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed4, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed4, zPrimed3), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed4, zPrimed3), t1), t2), FastNoiseLite.CubicLerp(FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed2, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed2, zPrimed4), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed1, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed1, zPrimed4), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed3, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed3, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed3, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed3, zPrimed4), t1), FastNoiseLite.CubicLerp(FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed4, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed4, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed3, yPrimed4, zPrimed4), FastNoiseLite.ValCoord(seed, xPrimed4, yPrimed4, zPrimed4), t1), t2), t3) * 0.2962963f;
    }

    private float SingleValue(int seed, float x, float y)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      float t1 = FastNoiseLite.InterpHermite(x - (float) num1);
      float t2 = FastNoiseLite.InterpHermite(y - (float) num2);
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      return FastNoiseLite.Lerp(FastNoiseLite.Lerp(FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1), FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1), t1), FastNoiseLite.Lerp(FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2), FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2), t1), t2);
    }

    private float SingleValue(int seed, float x, float y, float z)
    {
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      int num3 = FastNoiseLite.FastFloor(z);
      float t1 = FastNoiseLite.InterpHermite(x - (float) num1);
      float t2 = FastNoiseLite.InterpHermite(y - (float) num2);
      float t3 = FastNoiseLite.InterpHermite(z - (float) num3);
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int zPrimed1 = num3 * 1720413743;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      int zPrimed2 = zPrimed1 + 1720413743;
      double a1 = (double) FastNoiseLite.Lerp(FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1, zPrimed1), t1);
      float num4 = FastNoiseLite.Lerp(FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2, zPrimed1), FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2, zPrimed1), t1);
      float a2 = FastNoiseLite.Lerp(FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed1, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed1, zPrimed2), t1);
      float b1 = FastNoiseLite.Lerp(FastNoiseLite.ValCoord(seed, xPrimed1, yPrimed2, zPrimed2), FastNoiseLite.ValCoord(seed, xPrimed2, yPrimed2, zPrimed2), t1);
      double b2 = (double) num4;
      double t4 = (double) t2;
      return FastNoiseLite.Lerp(FastNoiseLite.Lerp((float) a1, (float) b2, (float) t4), FastNoiseLite.Lerp(a2, b1, t2), t3);
    }

    private void DoSingleDomainWarp(
      int seed,
      float amp,
      float freq,
      float x,
      float y,
      ref float xr,
      ref float yr)
    {
      switch (this.mDomainWarpType)
      {
        case FastNoiseLite.DomainWarpType.OpenSimplex2:
          this.SingleDomainWarpSimplexGradient(seed, amp * 38.2836876f, freq, x, y, ref xr, ref yr, false);
          break;
        case FastNoiseLite.DomainWarpType.OpenSimplex2Reduced:
          this.SingleDomainWarpSimplexGradient(seed, amp * 16f, freq, x, y, ref xr, ref yr, true);
          break;
        case FastNoiseLite.DomainWarpType.BasicGrid:
          this.SingleDomainWarpBasicGrid(seed, amp, freq, x, y, ref xr, ref yr);
          break;
      }
    }

    private void DoSingleDomainWarp(
      int seed,
      float amp,
      float freq,
      float x,
      float y,
      float z,
      ref float xr,
      ref float yr,
      ref float zr)
    {
      switch (this.mDomainWarpType)
      {
        case FastNoiseLite.DomainWarpType.OpenSimplex2:
          this.SingleDomainWarpOpenSimplex2Gradient(seed, amp * 32.6942825f, freq, x, y, z, ref xr, ref yr, ref zr, false);
          break;
        case FastNoiseLite.DomainWarpType.OpenSimplex2Reduced:
          this.SingleDomainWarpOpenSimplex2Gradient(seed, amp * 7.716049f, freq, x, y, z, ref xr, ref yr, ref zr, true);
          break;
        case FastNoiseLite.DomainWarpType.BasicGrid:
          this.SingleDomainWarpBasicGrid(seed, amp, freq, x, y, z, ref xr, ref yr, ref zr);
          break;
      }
    }

    private void DomainWarpSingle(ref float x, ref float y)
    {
      int mSeed = this.mSeed;
      float amp = this.mDomainWarpAmp * this.mFractalBounding;
      float mFrequency = this.mFrequency;
      float x1 = x;
      float y1 = y;
      this.TransformDomainWarpCoordinate(ref x1, ref y1);
      this.DoSingleDomainWarp(mSeed, amp, mFrequency, x1, y1, ref x, ref y);
    }

    private void DomainWarpSingle(ref float x, ref float y, ref float z)
    {
      int mSeed = this.mSeed;
      float amp = this.mDomainWarpAmp * this.mFractalBounding;
      float mFrequency = this.mFrequency;
      float x1 = x;
      float y1 = y;
      float z1 = z;
      this.TransformDomainWarpCoordinate(ref x1, ref y1, ref z1);
      this.DoSingleDomainWarp(mSeed, amp, mFrequency, x1, y1, z1, ref x, ref y, ref z);
    }

    private void DomainWarpFractalProgressive(ref float x, ref float y)
    {
      int mSeed = this.mSeed;
      float amp = this.mDomainWarpAmp * this.mFractalBounding;
      float mFrequency = this.mFrequency;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float x1 = x;
        float y1 = y;
        this.TransformDomainWarpCoordinate(ref x1, ref y1);
        this.DoSingleDomainWarp(mSeed, amp, mFrequency, x1, y1, ref x, ref y);
        ++mSeed;
        amp *= this.mGain;
        mFrequency *= this.mLacunarity;
      }
    }

    private void DomainWarpFractalProgressive(ref float x, ref float y, ref float z)
    {
      int mSeed = this.mSeed;
      float amp = this.mDomainWarpAmp * this.mFractalBounding;
      float mFrequency = this.mFrequency;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        float x1 = x;
        float y1 = y;
        float z1 = z;
        this.TransformDomainWarpCoordinate(ref x1, ref y1, ref z1);
        this.DoSingleDomainWarp(mSeed, amp, mFrequency, x1, y1, z1, ref x, ref y, ref z);
        ++mSeed;
        amp *= this.mGain;
        mFrequency *= this.mLacunarity;
      }
    }

    private void DomainWarpFractalIndependent(ref float x, ref float y)
    {
      float x1 = x;
      float y1 = y;
      this.TransformDomainWarpCoordinate(ref x1, ref y1);
      int mSeed = this.mSeed;
      float amp = this.mDomainWarpAmp * this.mFractalBounding;
      float mFrequency = this.mFrequency;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        this.DoSingleDomainWarp(mSeed, amp, mFrequency, x1, y1, ref x, ref y);
        ++mSeed;
        amp *= this.mGain;
        mFrequency *= this.mLacunarity;
      }
    }

    private void DomainWarpFractalIndependent(ref float x, ref float y, ref float z)
    {
      float x1 = x;
      float y1 = y;
      float z1 = z;
      this.TransformDomainWarpCoordinate(ref x1, ref y1, ref z1);
      int mSeed = this.mSeed;
      float amp = this.mDomainWarpAmp * this.mFractalBounding;
      float mFrequency = this.mFrequency;
      for (int index = 0; index < this.mOctaves; ++index)
      {
        this.DoSingleDomainWarp(mSeed, amp, mFrequency, x1, y1, z1, ref x, ref y, ref z);
        ++mSeed;
        amp *= this.mGain;
        mFrequency *= this.mLacunarity;
      }
    }

    private void SingleDomainWarpBasicGrid(
      int seed,
      float warpAmp,
      float frequency,
      float x,
      float y,
      ref float xr,
      ref float yr)
    {
      double f1 = (double) x * (double) frequency;
      float f2 = y * frequency;
      int num1 = FastNoiseLite.FastFloor((float) f1);
      int num2 = FastNoiseLite.FastFloor(f2);
      float t1 = FastNoiseLite.InterpHermite((float) f1 - (float) num1);
      float t2 = FastNoiseLite.InterpHermite(f2 - (float) num2);
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      int index1 = FastNoiseLite.Hash(seed, xPrimed1, yPrimed1) & 510;
      int index2 = FastNoiseLite.Hash(seed, xPrimed2, yPrimed1) & 510;
      float a1 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs2D[index1], FastNoiseLite.RandVecs2D[index2], t1);
      float a2 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs2D[index1 | 1], FastNoiseLite.RandVecs2D[index2 | 1], t1);
      int index3 = FastNoiseLite.Hash(seed, xPrimed1, yPrimed2) & 510;
      int index4 = FastNoiseLite.Hash(seed, xPrimed2, yPrimed2) & 510;
      float b1 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs2D[index3], FastNoiseLite.RandVecs2D[index4], t1);
      float b2 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs2D[index3 | 1], FastNoiseLite.RandVecs2D[index4 | 1], t1);
      xr += FastNoiseLite.Lerp(a1, b1, t2) * warpAmp;
      yr += FastNoiseLite.Lerp(a2, b2, t2) * warpAmp;
    }

    private void SingleDomainWarpBasicGrid(
      int seed,
      float warpAmp,
      float frequency,
      float x,
      float y,
      float z,
      ref float xr,
      ref float yr,
      ref float zr)
    {
      double f1 = (double) x * (double) frequency;
      float f2 = y * frequency;
      float f3 = z * frequency;
      int num1 = FastNoiseLite.FastFloor((float) f1);
      int num2 = FastNoiseLite.FastFloor(f2);
      int num3 = FastNoiseLite.FastFloor(f3);
      float t1 = FastNoiseLite.InterpHermite((float) f1 - (float) num1);
      float t2 = FastNoiseLite.InterpHermite(f2 - (float) num2);
      float t3 = FastNoiseLite.InterpHermite(f3 - (float) num3);
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int zPrimed1 = num3 * 1720413743;
      int xPrimed2 = xPrimed1 + 501125321;
      int yPrimed2 = yPrimed1 + 1136930381;
      int zPrimed2 = zPrimed1 + 1720413743;
      int index1 = FastNoiseLite.Hash(seed, xPrimed1, yPrimed1, zPrimed1) & 1020;
      int index2 = FastNoiseLite.Hash(seed, xPrimed2, yPrimed1, zPrimed1) & 1020;
      float a1 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index1], FastNoiseLite.RandVecs3D[index2], t1);
      float a2 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index1 | 1], FastNoiseLite.RandVecs3D[index2 | 1], t1);
      float a3 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index1 | 2], FastNoiseLite.RandVecs3D[index2 | 2], t1);
      int index3 = FastNoiseLite.Hash(seed, xPrimed1, yPrimed2, zPrimed1) & 1020;
      int index4 = FastNoiseLite.Hash(seed, xPrimed2, yPrimed2, zPrimed1) & 1020;
      float b1 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index3], FastNoiseLite.RandVecs3D[index4], t1);
      float b2 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index3 | 1], FastNoiseLite.RandVecs3D[index4 | 1], t1);
      float b3 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index3 | 2], FastNoiseLite.RandVecs3D[index4 | 2], t1);
      float a4 = FastNoiseLite.Lerp(a1, b1, t2);
      float a5 = FastNoiseLite.Lerp(a2, b2, t2);
      float a6 = FastNoiseLite.Lerp(a3, b3, t2);
      int index5 = FastNoiseLite.Hash(seed, xPrimed1, yPrimed1, zPrimed2) & 1020;
      int index6 = FastNoiseLite.Hash(seed, xPrimed2, yPrimed1, zPrimed2) & 1020;
      float a7 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index5], FastNoiseLite.RandVecs3D[index6], t1);
      float a8 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index5 | 1], FastNoiseLite.RandVecs3D[index6 | 1], t1);
      float a9 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index5 | 2], FastNoiseLite.RandVecs3D[index6 | 2], t1);
      int index7 = FastNoiseLite.Hash(seed, xPrimed1, yPrimed2, zPrimed2) & 1020;
      int index8 = FastNoiseLite.Hash(seed, xPrimed2, yPrimed2, zPrimed2) & 1020;
      float b4 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index7], FastNoiseLite.RandVecs3D[index8], t1);
      float b5 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index7 | 1], FastNoiseLite.RandVecs3D[index8 | 1], t1);
      float b6 = FastNoiseLite.Lerp(FastNoiseLite.RandVecs3D[index7 | 2], FastNoiseLite.RandVecs3D[index8 | 2], t1);
      xr += FastNoiseLite.Lerp(a4, FastNoiseLite.Lerp(a7, b4, t2), t3) * warpAmp;
      yr += FastNoiseLite.Lerp(a5, FastNoiseLite.Lerp(a8, b5, t2), t3) * warpAmp;
      zr += FastNoiseLite.Lerp(a6, FastNoiseLite.Lerp(a9, b6, t2), t3) * warpAmp;
    }

    private void SingleDomainWarpSimplexGradient(
      int seed,
      float warpAmp,
      float frequency,
      float x,
      float y,
      ref float xr,
      ref float yr,
      bool outGradOnly)
    {
      x *= frequency;
      y *= frequency;
      int num1 = FastNoiseLite.FastFloor(x);
      int num2 = FastNoiseLite.FastFloor(y);
      double num3 = (double) (x - (float) num1);
      float num4 = y - (float) num2;
      float num5 = (float) ((num3 + (double) num4) * 0.21132487058639526);
      float xd1 = (float) num3 - num5;
      float yd1 = num4 - num5;
      int xPrimed = num1 * 501125321;
      int yPrimed = num2 * 1136930381;
      float num6;
      float num7 = num6 = 0.0f;
      float num8 = (float) (0.5 - (double) xd1 * (double) xd1 - (double) yd1 * (double) yd1);
      if ((double) num8 > 0.0)
      {
        float num9 = (float) ((double) num8 * (double) num8 * ((double) num8 * (double) num8));
        float xo;
        float yo;
        if (outGradOnly)
          FastNoiseLite.GradCoordOut(seed, xPrimed, yPrimed, out xo, out yo);
        else
          FastNoiseLite.GradCoordDual(seed, xPrimed, yPrimed, xd1, yd1, out xo, out yo);
        num7 += num9 * xo;
        num6 += num9 * yo;
      }
      float num10 = (float) (3.1547005176544189 * (double) num5 + ((double) num8 - 0.66666662693023682));
      if ((double) num10 > 0.0)
      {
        float xd2 = xd1 - 0.577350259f;
        float yd2 = yd1 - 0.577350259f;
        float num11 = (float) ((double) num10 * (double) num10 * ((double) num10 * (double) num10));
        float xo;
        float yo;
        if (outGradOnly)
          FastNoiseLite.GradCoordOut(seed, xPrimed + 501125321, yPrimed + 1136930381, out xo, out yo);
        else
          FastNoiseLite.GradCoordDual(seed, xPrimed + 501125321, yPrimed + 1136930381, xd2, yd2, out xo, out yo);
        num7 += num11 * xo;
        num6 += num11 * yo;
      }
      if ((double) yd1 > (double) xd1)
      {
        float xd3 = xd1 + 0.211324871f;
        float yd3 = yd1 - 0.7886751f;
        float num12 = (float) (0.5 - (double) xd3 * (double) xd3 - (double) yd3 * (double) yd3);
        if ((double) num12 > 0.0)
        {
          float num13 = (float) ((double) num12 * (double) num12 * ((double) num12 * (double) num12));
          float xo;
          float yo;
          if (outGradOnly)
            FastNoiseLite.GradCoordOut(seed, xPrimed, yPrimed + 1136930381, out xo, out yo);
          else
            FastNoiseLite.GradCoordDual(seed, xPrimed, yPrimed + 1136930381, xd3, yd3, out xo, out yo);
          num7 += num13 * xo;
          num6 += num13 * yo;
        }
      }
      else
      {
        float xd4 = xd1 - 0.7886751f;
        float yd4 = yd1 + 0.211324871f;
        float num14 = (float) (0.5 - (double) xd4 * (double) xd4 - (double) yd4 * (double) yd4);
        if ((double) num14 > 0.0)
        {
          float num15 = (float) ((double) num14 * (double) num14 * ((double) num14 * (double) num14));
          float xo;
          float yo;
          if (outGradOnly)
            FastNoiseLite.GradCoordOut(seed, xPrimed + 501125321, yPrimed, out xo, out yo);
          else
            FastNoiseLite.GradCoordDual(seed, xPrimed + 501125321, yPrimed, xd4, yd4, out xo, out yo);
          num7 += num15 * xo;
          num6 += num15 * yo;
        }
      }
      xr += num7 * warpAmp;
      yr += num6 * warpAmp;
    }

    private void SingleDomainWarpOpenSimplex2Gradient(
      int seed,
      float warpAmp,
      float frequency,
      float x,
      float y,
      float z,
      ref float xr,
      ref float yr,
      ref float zr,
      bool outGradOnly)
    {
      x *= frequency;
      y *= frequency;
      z *= frequency;
      int num1 = FastNoiseLite.FastRound(x);
      int num2 = FastNoiseLite.FastRound(y);
      int num3 = FastNoiseLite.FastRound(z);
      float xd1 = x - (float) num1;
      float yd1 = y - (float) num2;
      float zd1 = z - (float) num3;
      int num4 = (int) (-(double) xd1 - 1.0) | 1;
      int num5 = (int) (-(double) yd1 - 1.0) | 1;
      int num6 = (int) (-(double) zd1 - 1.0) | 1;
      float num7 = (float) num4 * -xd1;
      float num8 = (float) num5 * -yd1;
      float num9 = (float) num6 * -zd1;
      int xPrimed1 = num1 * 501125321;
      int yPrimed1 = num2 * 1136930381;
      int zPrimed1 = num3 * 1720413743;
      double num10;
      float num11 = (float) (num10 = 0.0);
      float num12 = (float) num10;
      float num13 = (float) num10;
      float num14 = (float) (0.60000002384185791 - (double) xd1 * (double) xd1 - ((double) yd1 * (double) yd1 + (double) zd1 * (double) zd1));
      int num15 = 0;
      while (true)
      {
        if ((double) num14 > 0.0)
        {
          float num16 = (float) ((double) num14 * (double) num14 * ((double) num14 * (double) num14));
          float xo;
          float yo;
          float zo;
          if (outGradOnly)
            FastNoiseLite.GradCoordOut(seed, xPrimed1, yPrimed1, zPrimed1, out xo, out yo, out zo);
          else
            FastNoiseLite.GradCoordDual(seed, xPrimed1, yPrimed1, zPrimed1, xd1, yd1, zd1, out xo, out yo, out zo);
          num13 += num16 * xo;
          num12 += num16 * yo;
          num11 += num16 * zo;
        }
        float num17 = num14;
        int xPrimed2 = xPrimed1;
        int yPrimed2 = yPrimed1;
        int zPrimed2 = zPrimed1;
        float xd2 = xd1;
        float yd2 = yd1;
        float zd2 = zd1;
        float num18;
        if ((double) num7 >= (double) num8 && (double) num7 >= (double) num9)
        {
          xd2 += (float) num4;
          num18 = num17 + num7 + num7;
          xPrimed2 -= num4 * 501125321;
        }
        else if ((double) num8 > (double) num7 && (double) num8 >= (double) num9)
        {
          yd2 += (float) num5;
          num18 = num17 + num8 + num8;
          yPrimed2 -= num5 * 1136930381;
        }
        else
        {
          zd2 += (float) num6;
          num18 = num17 + num9 + num9;
          zPrimed2 -= num6 * 1720413743;
        }
        if ((double) num18 > 1.0)
        {
          float num19 = num18 - 1f;
          float num20 = (float) ((double) num19 * (double) num19 * ((double) num19 * (double) num19));
          float xo;
          float yo;
          float zo;
          if (outGradOnly)
            FastNoiseLite.GradCoordOut(seed, xPrimed2, yPrimed2, zPrimed2, out xo, out yo, out zo);
          else
            FastNoiseLite.GradCoordDual(seed, xPrimed2, yPrimed2, zPrimed2, xd2, yd2, zd2, out xo, out yo, out zo);
          num13 += num20 * xo;
          num12 += num20 * yo;
          num11 += num20 * zo;
        }
        if (num15 != 1)
        {
          num7 = 0.5f - num7;
          num8 = 0.5f - num8;
          num9 = 0.5f - num9;
          xd1 = (float) num4 * num7;
          yd1 = (float) num5 * num8;
          zd1 = (float) num6 * num9;
          num14 += (float) (0.75 - (double) num7 - ((double) num8 + (double) num9));
          xPrimed1 += num4 >> 1 & 501125321;
          yPrimed1 += num5 >> 1 & 1136930381;
          zPrimed1 += num6 >> 1 & 1720413743;
          num4 = -num4;
          num5 = -num5;
          num6 = -num6;
          seed += 1293373;
          ++num15;
        }
        else
          break;
      }
      xr += num13 * warpAmp;
      yr += num12 * warpAmp;
      zr += num11 * warpAmp;
    }

    public enum NoiseType
    {
      OpenSimplex2,
      OpenSimplex2S,
      Cellular,
      Perlin,
      ValueCubic,
      Value,
    }

    public enum RotationType3D
    {
      None,
      ImproveXYPlanes,
      ImproveXZPlanes,
    }

    public enum FractalType
    {
      None,
      FBm,
      Ridged,
      PingPong,
      DomainWarpProgressive,
      DomainWarpIndependent,
    }

    public enum CellularDistanceFunction
    {
      Euclidean,
      EuclideanSq,
      Manhattan,
      Hybrid,
    }

    public enum CellularReturnType
    {
      CellValue,
      Distance,
      Distance2,
      Distance2Add,
      Distance2Sub,
      Distance2Mul,
      Distance2Div,
    }

    public enum DomainWarpType
    {
      OpenSimplex2,
      OpenSimplex2Reduced,
      BasicGrid,
    }

    private enum TransformType3D
    {
      None,
      ImproveXYPlanes,
      ImproveXZPlanes,
      DefaultOpenSimplex2,
    }
  }
}
